diff -Naurp binutils-2.23.1/bfd/archures.c binutils-2.23.1.new/bfd/archures.c
--- binutils-2.23.1/bfd/archures.c	2012-09-04 15:53:41.000000000 +0300
+++ binutils-2.23.1.new/bfd/archures.c	2017-08-26 00:16:15.035101896 +0300
@@ -154,11 +154,17 @@ DESCRIPTION
 .#define bfd_mach_mips4100		4100
 .#define bfd_mach_mips4111		4111
 .#define bfd_mach_mips4120		4120
+.#define bfd_mach_mips4180		4180
+.#define bfd_mach_mips4181		4181
+.#define bfd_mach_mips4281		4281
 .#define bfd_mach_mips4300		4300
 .#define bfd_mach_mips4400		4400
 .#define bfd_mach_mips4600		4600
 .#define bfd_mach_mips4650		4650
 .#define bfd_mach_mips5000		5000
+.#define bfd_mach_mips5181		5181
+.#define bfd_mach_mips5280		5280
+.#define bfd_mach_mips5281		5281
 .#define bfd_mach_mips5400		5400
 .#define bfd_mach_mips5500		5500
 .#define bfd_mach_mips6000		6000
diff -Naurp binutils-2.23.1/bfd/bfd-in2.h binutils-2.23.1.new/bfd/bfd-in2.h
--- binutils-2.23.1/bfd/bfd-in2.h	2012-09-04 15:53:41.000000000 +0300
+++ binutils-2.23.1.new/bfd/bfd-in2.h	2017-08-27 09:26:49.000000000 +0300
@@ -1883,11 +1883,17 @@ enum bfd_architecture
 #define bfd_mach_mips4100              4100
 #define bfd_mach_mips4111              4111
 #define bfd_mach_mips4120              4120
+#define bfd_mach_mips4180              4180
+#define bfd_mach_mips4181              4181
+#define bfd_mach_mips4281              4281
 #define bfd_mach_mips4300              4300
 #define bfd_mach_mips4400              4400
 #define bfd_mach_mips4600              4600
 #define bfd_mach_mips4650              4650
 #define bfd_mach_mips5000              5000
+#define bfd_mach_mips5181              5181
+#define bfd_mach_mips5280              5280
+#define bfd_mach_mips5281              5281
 #define bfd_mach_mips5400              5400
 #define bfd_mach_mips5500              5500
 #define bfd_mach_mips6000              6000
@@ -2284,7 +2290,8 @@ typedef enum bfd_reloc_status
      generated only when linking i960 coff files with i960 b.out
      symbols.  If this type is returned, the error_message argument
      to bfd_perform_relocation will be set.  */
-  bfd_reloc_dangerous
+  bfd_reloc_dangerous,
+  bfd_reloc_notmultipleof8_ltw
  }
  bfd_reloc_status_type;
 
@@ -5480,6 +5487,8 @@ giving a 16 bit signed byte offset.  */
 
 /* Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.  */
   BFD_RELOC_EPIPHANY_IMM8,
+/* Lexra reloc */
+  BFD_RELOC_OFF6A,
   BFD_RELOC_UNUSED };
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
 reloc_howto_type *bfd_reloc_type_lookup
diff -Naurp binutils-2.23.1/bfd/cpu-mips.c binutils-2.23.1.new/bfd/cpu-mips.c
--- binutils-2.23.1/bfd/cpu-mips.c	2012-01-31 19:54:35.000000000 +0200
+++ binutils-2.23.1.new/bfd/cpu-mips.c	2017-08-25 21:17:45.972935261 +0300
@@ -68,11 +68,17 @@ enum
   I_mips4100,
   I_mips4111,
   I_mips4120,
+  I_mips4180,
+  I_mips4181,
+  I_mips4281,
   I_mips4300,
   I_mips4400,
   I_mips4600,
   I_mips4650,
   I_mips5000,
+  I_mips5181,
+  I_mips5280,
+  I_mips5281,
   I_mips5400,
   I_mips5500,
   I_mips6000,
@@ -111,11 +117,17 @@ static const bfd_arch_info_type arch_inf
   N (64, 64, bfd_mach_mips4100, "mips:4100",      FALSE, NN(I_mips4100)),
   N (64, 64, bfd_mach_mips4111, "mips:4111",      FALSE, NN(I_mips4111)),
   N (64, 64, bfd_mach_mips4120, "mips:4120",      FALSE, NN(I_mips4120)),
+  N (32, 32, bfd_mach_mips4180, "mips:4180",      FALSE, NN(I_mips4180)),
+  N (32, 32, bfd_mach_mips4181, "mips:4181",      FALSE, NN(I_mips4181)),
+  N (32, 32, bfd_mach_mips4281, "mips:4281",      FALSE, NN(I_mips4281)),
   N (64, 64, bfd_mach_mips4300, "mips:4300",      FALSE, NN(I_mips4300)),
   N (64, 64, bfd_mach_mips4400, "mips:4400",      FALSE, NN(I_mips4400)),
   N (64, 64, bfd_mach_mips4600, "mips:4600",      FALSE, NN(I_mips4600)),
   N (64, 64, bfd_mach_mips4650, "mips:4650",      FALSE, NN(I_mips4650)),
   N (64, 64, bfd_mach_mips5000, "mips:5000",      FALSE, NN(I_mips5000)),
+  N (32, 32, bfd_mach_mips5181, "mips:5181",      FALSE, NN(I_mips5181)),
+  N (32, 32, bfd_mach_mips5280, "mips:5280",      FALSE, NN(I_mips5280)),
+  N (32, 32, bfd_mach_mips5281, "mips:5281",      FALSE, NN(I_mips5281)),
   N (64, 64, bfd_mach_mips5400, "mips:5400",      FALSE, NN(I_mips5400)),
   N (64, 64, bfd_mach_mips5500, "mips:5500",      FALSE, NN(I_mips5500)),
   N (32, 32, bfd_mach_mips6000, "mips:6000",      FALSE, NN(I_mips6000)),
diff -Naurp binutils-2.23.1/bfd/elf32-mips.c binutils-2.23.1.new/bfd/elf32-mips.c
--- binutils-2.23.1/bfd/elf32-mips.c	2011-12-19 09:57:59.000000000 +0200
+++ binutils-2.23.1.new/bfd/elf32-mips.c	2017-08-25 21:17:45.980933560 +0300
@@ -717,6 +717,20 @@ static reloc_howto_type elf_mips_howto_t
 	 0x0,			/* src_mask */
 	 0xffffffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
+  /* relocation added by dbb */
+  HOWTO (R_RELOC_OFF6A,         /* type */
+	 3,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 10,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 6,                     /* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,                  /* special_function */
+	 "R_RELOC_OFF6A",       /* name */
+	 TRUE,                  /* partial_inplace */
+	 0x0000FFC0,            /* src_mask */
+	 0x0000FFC0,            /* dst_mask */
+	 FALSE),                /* pcrel_offset */
 };
 
 /* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
@@ -1890,7 +1904,8 @@ static const struct elf_reloc_map mips_r
   { BFD_RELOC_MIPS_TLS_TPREL32, R_MIPS_TLS_TPREL32 },
   { BFD_RELOC_MIPS_TLS_TPREL64, R_MIPS_TLS_TPREL64 },
   { BFD_RELOC_MIPS_TLS_TPREL_HI16, R_MIPS_TLS_TPREL_HI16 },
-  { BFD_RELOC_MIPS_TLS_TPREL_LO16, R_MIPS_TLS_TPREL_LO16 }
+  { BFD_RELOC_MIPS_TLS_TPREL_LO16, R_MIPS_TLS_TPREL_LO16 },
+  { BFD_RELOC_OFF6A, R_RELOC_OFF6A}
 };
 
 static const struct elf_reloc_map mips16_reloc_map[] =
diff -Naurp binutils-2.23.1/bfd/elfxx-mips.c binutils-2.23.1.new/bfd/elfxx-mips.c
--- binutils-2.23.1/bfd/elfxx-mips.c	2012-09-04 17:19:46.000000000 +0300
+++ binutils-2.23.1.new/bfd/elfxx-mips.c	2017-08-25 21:17:45.988931858 +0300
@@ -5676,6 +5676,12 @@ mips_elf_calculate_relocation (bfd *abfd
 	}
       break;
 
+    case R_RELOC_OFF6A:
+      value = (symbol + ((addend >> 6) << 3));
+      if ((value % 8) != 0)
+	return bfd_reloc_notmultipleof8_ltw;
+      value = ((value >> 3) << 6) & howto->dst_mask;
+      break;
     case R_MIPS_LITERAL:
     case R_MICROMIPS_LITERAL:
       /* Because we don't merge literal sections, we can handle this
@@ -9666,6 +9672,12 @@ _bfd_mips_elf_relocate_section (bfd *out
 	    }
 	  break;
 
+	case bfd_reloc_notmultipleof8_ltw:
+	  msg = _("offset in ltw instruction is not multiple of 8");
+	  info->callbacks->warning
+	    (info, msg, name, input_bfd, input_section, rel->r_offset);
+	  return FALSE;
+
 	case bfd_reloc_ok:
 	  break;
 
diff -Naurp binutils-2.23.1/bfd/libbfd.h binutils-2.23.1.new/bfd/libbfd.h
--- binutils-2.23.1/bfd/libbfd.h	2012-09-04 15:53:42.000000000 +0300
+++ binutils-2.23.1.new/bfd/libbfd.h	2017-08-27 09:34:00.000000000 +0300
@@ -2656,6 +2656,7 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_EPIPHANY_SIMM11",
   "BFD_RELOC_EPIPHANY_IMM11",
   "BFD_RELOC_EPIPHANY_IMM8",
+  "BFD_RELOC_OFF6A",
  "@@overflow: BFD_RELOC_UNUSED@@",
 };
 #endif
diff -Naurp binutils-2.23.1/bfd/reloc.c binutils-2.23.1.new/bfd/reloc.c
--- binutils-2.23.1/bfd/reloc.c	2012-09-04 15:53:42.000000000 +0300
+++ binutils-2.23.1.new/bfd/reloc.c	2017-08-26 00:22:45.305461139 +0300
@@ -53,6 +53,7 @@ SECTION
 #include "bfd.h"
 #include "bfdlink.h"
 #include "libbfd.h"
+#include "elf/mips.h"
 /*
 DOCDD
 INODE
@@ -92,7 +93,8 @@ CODE_FRAGMENT
 .     generated only when linking i960 coff files with i960 b.out
 .     symbols.  If this type is returned, the error_message argument
 .     to bfd_perform_relocation will be set.  *}
-.  bfd_reloc_dangerous
+.  bfd_reloc_dangerous,
+.  bfd_reloc_notmultipleof8_ltw
 . }
 . bfd_reloc_status_type;
 .
@@ -1213,6 +1215,15 @@ space consuming.  For each target:
      }
      */
 
+
+  switch (howto->type)
+    {
+    case R_RELOC_OFF6A:
+      if ((relocation % 8) != 0)
+        return bfd_reloc_notmultipleof8_ltw;
+      break;
+    }
+
   relocation >>= (bfd_vma) howto->rightshift;
 
   /* Shift everything up to where it's going to be used.  */
@@ -6536,6 +6547,10 @@ ENUM
 ENUMDOC
   Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.
 
+ENUM
+  BFD_RELOC_OFF6A
+ENUMDOC
+  Lexra reloc
 
 ENDSENUM
   BFD_RELOC_UNUSED
diff -Naurp binutils-2.23.1/gas/config/tc-mips.c binutils-2.23.1.new/gas/config/tc-mips.c
--- binutils-2.23.1/gas/config/tc-mips.c	2012-09-04 17:21:03.000000000 +0300
+++ binutils-2.23.1.new/gas/config/tc-mips.c	2017-08-25 21:17:46.028923377 +0300
@@ -102,6 +102,32 @@ static char *mips_regmask_frag;
 #define FP  30
 #define RA  31
 
+#define M0L      1
+#define M0H      2
+#define M0       3
+#define M1L      5
+#define M1H      6
+#define M1       7
+#define M2L      9
+#define M2H     10
+#define M2      11
+#define M3L     13
+#define M3H     14
+#define M3      15
+#define ESTATUS  0
+#define ECAUSE   1
+#define INTVEC   2
+#define CBS0     0
+#define CBS1     1
+#define CBS2     2
+#define CBE0     4
+#define CBE1     5
+#define CBE2     6
+#define LPS0    16
+#define LPE0    17
+#define LPC0    18
+#define MMD     24
+
 #define ILLEGAL_REG (32)
 
 #define AT  mips_opts.at
@@ -299,6 +325,8 @@ static struct mips_set_options mips_opts
   /* sym32 */ FALSE, /* soft_float */ FALSE, /* single_float */ FALSE
 };
 
+static const struct mips_opcode dummy_opcode = { NULL, NULL, 0, 0, 0, 0, 0 };
+
 /* These variables are filled in with the masks of registers used.
    The object format code reads them and puts them in the appropriate
    place.  */
@@ -540,6 +568,9 @@ static int mips_32bitmode = 0;
 #define gpr_interlocks                                \
   (mips_opts.isa != ISA_MIPS1                         \
    || mips_opts.arch == CPU_R3900                     \
+   || mips_opts.arch == CPU_RLX4281                   \
+   || mips_opts.arch == CPU_LX5280                    \
+   || mips_opts.arch == CPU_RLX5281                   \
    || mips_opts.micromips                             \
    )
 
@@ -1364,6 +1395,10 @@ static void s_mips_loc (int);
 static bfd_boolean pic_need_relax (symbolS *, asection *);
 static int relaxed_branch_length (fragS *, asection *, int);
 static int validate_mips_insn (const struct mips_opcode *);
+static inline int rlx_nops_for_new_insn (const struct mips_cl_insn *, const struct mips_cl_insn *);
+static inline int rlx_is_insn_lt (const struct mips_cl_insn *, const struct mips_cl_insn *);
+static inline int rlx_is_insn_st (const struct mips_cl_insn *, const struct mips_cl_insn *);
+static inline int rlx_is_insn_swappable (const struct mips_cl_insn *, const struct mips_cl_insn *);
 static int validate_micromips_insn (const struct mips_opcode *);
 static int relaxed_micromips_16bit_branch_length (fragS *, asection *, int);
 static int relaxed_micromips_32bit_branch_length (fragS *, asection *, int);
@@ -1995,6 +2030,34 @@ struct regname {
 #define MIPS16_SPECIAL_REGISTER_NAMES \
     {"$pc",	RTYPE_PC | 0}
 
+#define RLX_REGISTER_ALIAS_NAMES \
+    {"$m0l",	RTYPE_GP | 1},  \
+    {"$m0h",	RTYPE_GP | 2},  \
+    {"$m0",	RTYPE_GP | 3},  \
+    {"$m1l",	RTYPE_GP | 5},  \
+    {"$m1h",	RTYPE_GP | 6},  \
+    {"$m1",	RTYPE_GP | 7},  \
+    {"$m2l",	RTYPE_GP | 9}, \
+    {"$m2h",	RTYPE_GP | 10}, \
+    {"$m2",	RTYPE_GP | 11}, \
+    {"$m3l",	RTYPE_GP | 13}, \
+    {"$m3l",	RTYPE_GP | 14}, \
+    {"$m3",	RTYPE_GP | 15}, \
+    {"$estatus",	RTYPE_GP | 0}, \
+    {"$ecause",	RTYPE_GP | 1}, \
+    {"$intvec",	RTYPE_GP | 2}, \
+    {"$mmd",	RTYPE_GP | 24}, \
+    {"$cbs0",	RTYPE_GP | 0}, \
+    {"$cbs1",	RTYPE_GP | 1}, \
+    {"$cbs2",	RTYPE_GP | 2}, \
+    {"$cbe0",	RTYPE_GP | 4}, \
+    {"$cbe1",	RTYPE_GP | 5}, \
+    {"$cbe2",	RTYPE_GP | 6}, \
+    {"$lps0",	RTYPE_GP | 16}, \
+    {"$lpe0",	RTYPE_GP | 17}, \
+    {"$lpc0",	RTYPE_GP | 18}
+
+
 #define MDMX_VECTOR_REGISTER_NAMES \
     /* {"$v0",	RTYPE_VEC | 0},  clash with REG 2 above */ \
     /* {"$v1",	RTYPE_VEC | 1},  clash with REG 3 above */ \
@@ -2048,6 +2111,7 @@ static const struct regname reg_names[]
   SYMBOLIC_REGISTER_NAMES,
 
   MIPS16_SPECIAL_REGISTER_NAMES,
+  RLX_REGISTER_ALIAS_NAMES,
   MDMX_VECTOR_REGISTER_NAMES,
   MIPS_DSP_ACCUMULATOR_NAMES,
   {0, 0}
@@ -3250,6 +3314,13 @@ insns_between (const struct mips_cl_insn
 	  || (!cop_interlocks && (pinfo1 & INSN_LOAD_COPROC_DELAY)))
 	{
 	  know (pinfo1 & INSN_WRITE_GPR_T);
+
+       /* 2006-01-06 tonywu: insn2 == NULL => mips_optimize = 0 */
+       /* 2006-10-16 tonywu: fix lt nop bug */
+      if (rlx_is_insn_lt (insn1, insn2) || rlx_is_insn_st (insn1, insn2))
+	  return 1;
+       /* 2006-10-16 tonywu: fix lt nop bug */
+
 	  if (INSN2_USES_GPR (EXTRACT_OPERAND (0, RT, *insn1)))
 	    return 1;
 	}
@@ -3303,7 +3374,7 @@ insns_between (const struct mips_cl_insn
 
 #undef INSN2_USES_GPR
 
-  return 0;
+  return rlx_nops_for_new_insn (insn1, insn2);
 }
 
 /* Return the number of nops that would be needed to work around the
@@ -3575,6 +3646,36 @@ nops_for_insn (int ignore, const struct
   return nops;
 }
 
+/* 2006-01-09 tonywu: fix branch delay slot filling bug */
+static inline int
+rlx_is_insn_swappable (const struct mips_cl_insn *history,
+                       const struct mips_cl_insn *insn)
+{
+
+  unsigned long pinfo1, pinfo2;
+
+  pinfo1 = history[0].insn_mo->pinfo;
+  pinfo2 = history[1].insn_mo->pinfo;
+
+  if (pinfo1 & INSN_LOAD_MEMORY_DELAY || pinfo1 & INSN_WRITE_GPR_T)
+    {
+        if ((gpr_read_mask (insn) & gpr_write_mask (&history[0])) != 0)
+        {
+          return 1;
+        }
+    }
+
+  if (pinfo2 & INSN_LOAD_MEMORY_DELAY || pinfo1 & INSN_WRITE_GPR_T)
+    {
+	if ((gpr_read_mask (insn) & gpr_write_mask (&history[1])) != 0)      
+        {
+          return 1;
+        }
+    }
+  return 0;
+}
+
+
 /* The variable arguments provide NUM_INSNS extra instructions that
    might be added to HIST.  Return the largest number of nops that
    would be needed after the extended sequence, ignoring hazards
@@ -3752,11 +3853,16 @@ can_swap_branch_p (struct mips_cl_insn *
   if (nops_for_sequence (2, 0, history + 1, ip, history) > 0)
     return FALSE;
 
+  if (rlx_is_insn_swappable (history, ip) > 0)
+    return FALSE;
+
   /* If the branch reads a register that the previous
      instruction sets, we can not swap.  */
   gpr_read = gpr_read_mask (ip);
   prev_gpr_write = gpr_write_mask (&history[0]);
-  if (gpr_read & prev_gpr_write)
+  if ((gpr_read & prev_gpr_write) 
+	/* 2006-01-06 tonywu: add for lt/ltw */
+	&& (!rlx_is_insn_lt (history, ip)))
     return FALSE;
 
   /* If the branch writes a register that the previous
@@ -10297,6 +10403,32 @@ validate_mips_insn (const struct mips_op
       case '1':	USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
       case '2': USE_BITS (OP_MASK_BP,		OP_SH_BP);	break;
       case '3': USE_BITS (OP_MASK_SA3,  	OP_SH_SA3);	break;
+      /* 2006-01-04 tonywu: merged from 2.14 to 2.16 */
+      case '#':
+        switch (c = *p++)
+          {
+            /* dbb: new instructions support */
+          case '`': USE_BITS (OP_MASK_EVENREG,		 OP_SH_EVENREG); 		break;
+          case '~': USE_BITS (OP_MASK_IMMIDATE88,	 OP_SH_IMMIDATE88); 		break;
+          case '#': USE_BITS (OP_MASK_IMMIDATE74,	 OP_SH_IMMIDATE74); 		break;
+          case '@': USE_BITS (OP_MASK_IMMIDATE6b,	 OP_SH_IMMIDATE6b); 		break;
+          case '-': USE_BITS (OP_MASK_OFFSET6A,		 OP_SH_OFFSET6A); 		break;
+            /* dbb: new instructions support */
+            /* 2008-07-08 tonywu: add for taroko processor */
+          case 'H': USE_BITS (OP_MASK_RLX_SEL,		 OP_SH_RLX_SEL); 		break;
+          case 'I': USE_BITS (OP_MASK_RLX_STYPE,	 OP_SH_RLX_STYPE); 		break;
+          case 'd': USE_BITS (OP_MASK_RD,		 OP_SH_RD);		p++; 	break;
+          case 's': USE_BITS (OP_MASK_RS,		 OP_SH_RS);		p++; 	break;
+          case 't': USE_BITS (OP_MASK_RT,		 OP_SH_RT);		p++; 	break;
+          case 'u': USE_BITS (OP_MASK_RD,		 OP_SH_RD); 			break;
+          case 'k': USE_BITS (OP_MASK_RD,		 OP_SH_RD); 			break;
+            /* 2008-07-08 tonywu: add for taroko processor */
+          default:
+            as_bad (_("internal: bad rlx opcode (unknown extension operand type `#%c'): %s %s"),
+                    c, opc->name, opc->args);
+            return 0;
+          }
+        break;
       case '4': USE_BITS (OP_MASK_SA4,  	OP_SH_SA4);	break;
       case '5': USE_BITS (OP_MASK_IMM8, 	OP_SH_IMM8);	break;
       case '6': USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
@@ -10320,6 +10452,7 @@ validate_mips_insn (const struct mips_op
 	return 0;
       }
 #undef USE_BITS
+  if (strcmp (opc->name, "sleep") != 0)
   if (used_bits != 0xffffffff)
     {
       as_bad (_("internal: bad mips opcode (bits 0x%lx undefined): %s %s"),
@@ -10608,6 +10741,7 @@ mips_ip (char *str, struct mips_cl_insn
   char *s;
   const char *args;
   char c = 0;
+  char t = 0;
   struct mips_opcode *insn;
   char *argsStart;
   unsigned int regno;
@@ -10617,6 +10751,7 @@ mips_ip (char *str, struct mips_cl_insn
   unsigned int limlo, limhi;
   char *s_reset;
   offsetT min_range, max_range;
+  int multipletype;
   long opend;
   char *name;
   int argnum;
@@ -11464,8 +11599,32 @@ mips_ip (char *str, struct mips_cl_insn
 		    break;
 		  if (regno == AT && mips_opts.at)
 		    {
-		      if (mips_opts.at == ATREG)
-			as_warn (_("used $at without \".set noat\""));
+		      if (mips_opts.at == ATREG) {
+                        if ((strncmp (ip->insn_mo->name, "mta2", 4) != 0
+                             || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "mfa", 3) != 0
+                                || *args != 't')
+                            && (strncmp (ip->insn_mo->name, "diva", 4) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "mtru", 4) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "mfru", 4) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "multa", 5) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "mulna2", 6) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "cmulta", 6) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "madda", 5) != 0
+                                || *args != 'd')
+                            && (strncmp (ip->insn_mo->name, "msuba", 5) != 0
+                                || *args != 'd')
+                            && strncmp (ip->insn_mo->name, "addma", 5) != 0
+                            && strncmp (ip->insn_mo->name, "subma", 5) != 0
+                            && strncmp (ip->insn_mo->name, "rnda2", 5) != 0)
+			      as_warn (_("used $at without \".set noat\""));
+		        }
 		      else
 			as_warn (_("used $%u with \".set at=$%u\""),
 				 regno, mips_opts.at);
@@ -11752,6 +11911,339 @@ mips_ip (char *str, struct mips_cl_insn
 	      }
 	      break;
 
+            case '#':
+              switch (*++args)
+                {
+                case 'd':
+                case 's':
+                case 't':
+                  s_reset = s;
+                  regno = 32;
+                  if (s[0] == '$')
+                    {
+                     reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno);
+                    }
+
+                  /* 2006-11-28 tonywu: add radiax alias name */
+                  c = *args;
+                  t = *++args;
+
+                  /* Now that we have assembled one operand, we use the args string
+                   * to figure out where it goes in the instruction.  */
+                  switch (t)
+                    {
+                    case '1':  /* m0(3), m1(7), m2(11), m3(15) */
+                      if (regno <= 0 || regno > 15 || (regno & 3) != 3)
+                        as_bad (_
+                                ("RADIAX: illegal register (%d) in %s type d%c"),
+                                regno, str, t);
+                      break;
+
+                    case '2':  /* m0l, m0h, m0 ~ m3l, m3h, m3 */
+                      if (regno <= 0 || regno > 15 || (regno & 3) == 0)
+                        as_bad (_
+                                ("RADIAX: illegal register (%d) in %s type d%c"),
+                                regno, str, t);
+                      break;
+
+                    case '3':  /* m0l, m0h, ~ m3l, m3h */
+                      if (regno <= 0 || regno > 15
+                          || (regno & 3) == 0 || (regno & 3) == 3)
+                        as_bad (_
+                                ("RADIAX: illegal register (%d) in %s type d%c"),
+                                regno, str, t);
+                      break;
+
+                    case '4':  /* LXC0 registers */
+                      if (regno > 31)
+                        as_bad (_
+                                ("RLX: illegal register (%d) in %s type d%c"),
+                                regno, str, t);
+                      break;
+
+                    default:
+                      as_bad (_("RLX: illegal register type d%c in %s"), t,
+                              str);
+                      break;
+                    }
+
+                  switch (c)
+                    {
+                    case 'd':
+                      INSERT_OPERAND (0, RD, *ip, regno);
+                      break;
+                    case 's':
+                      INSERT_OPERAND (0, RS, *ip, regno);
+                      break;
+                    case 't':
+                      INSERT_OPERAND (0, RT, *ip, regno);
+                      break;
+                    }
+
+                  lastregno = regno;
+                  continue;
+
+                case 'u':
+                case 'k':
+                  s_reset = s;
+                  regno = 32;
+                  if (s[0] == '$')
+                    {
+                     reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno);
+                    }
+                  /* 2006-11-28 tonywu: add radiax alias name */
+                  c = *args;
+
+                  /* Now that we have assembled one operand, we use the args string
+                   * to figure out where it goes in the instruction.  */
+                  if (regno == 32)
+                    as_bad (_("RLX: illegal register (%d) in %s"), regno,
+                            str);
+
+                  switch (c)
+                    {
+                    case 'u':
+                      INSERT_OPERAND (0, RD, *ip, regno);
+                      break;
+                    case 'k':
+                      INSERT_OPERAND (0, RD, *ip, regno);
+                      break;
+                    }
+
+                  lastregno = regno;
+                  continue;
+
+                case '-':
+                  /* 10bits offset used in ltw (OP_*_OFFSET6A),
+                   * in fact it is 13 bits,multiple of 8; */
+                  if (*s == '(' && strchr (s + 1, '(') == 0)
+                    {
+                      imm_expr.X_op = O_constant;
+                      imm_expr.X_add_number = 0;
+                      continue;
+                    }
+                  my_getExpression (&imm_expr, s);
+                  check_absolute_expr (ip, &imm_expr);
+                  if (imm_expr.X_op == O_constant)
+                    {
+                      if ((imm_expr.X_add_number % 8) != 0)
+                        as_bad (_("(%d) is not multiple of 8"),
+                                (int) imm_expr.X_add_number);
+                      if (((imm_expr.X_add_number + 4096) & ~0x1FFF) != 0)
+                        as_bad (_("(%d) is too large to fit in 13 bits"),
+                                (int) imm_expr.X_add_number);
+                      ip->insn_opcode |=
+                        (((imm_expr.X_add_number >> 3) & OP_MASK_OFFSET6A) <<
+                         OP_SH_OFFSET6A);
+                      imm_expr.X_op = O_absent;
+                    }
+                  else
+                    {
+                      *imm_reloc = BFD_RELOC_OFF6A;
+                    }
+                  s = expr_end;
+                  continue;
+                  /* 11 bits immediate used in lt,st (OP_*_IMMIDATE6b),
+                   * in fact it is 14 bits, multiple of 8; */
+                case '@':
+                  if (*s == '(' && strchr (s + 1, '(') == 0)
+                    {
+                      imm_expr.X_op = O_constant;
+                      imm_expr.X_add_number = 0;
+                      continue;
+                    }
+                  my_getExpression (&imm_expr, s);
+                  check_absolute_expr (ip, &imm_expr);
+                  if (imm_expr.X_add_number % 8 != 0)
+                    as_bad (_("(%d) is not multiple of 8"),
+                            (int) imm_expr.X_add_number);
+                  if (((imm_expr.X_add_number + 8192) & ~0x3FFF) != 0)
+                  if (((imm_expr.X_add_number + 8192) & ~0x3FFF) != 0)
+                    as_bad (_("(%d) is too large to fit in 14 bits"),
+                            (int) imm_expr.X_add_number);
+                  ip->insn_opcode |=
+                    (((imm_expr.X_add_number >> 3) & OP_MASK_IMMIDATE6b) <<
+                     OP_SH_IMMIDATE6b);
+                  imm_expr.X_op = O_absent;
+                  s = expr_end;
+                  continue;
+
+                  /* 4 bits immediate from 0 to 8,used in MFA,MFA2,RNDA2 (OP_*_IMMIDATE74) */
+                case '#':
+                  my_getExpression (&imm_expr, s);
+                  check_absolute_expr (ip, &imm_expr);
+                  if (imm_expr.X_add_number > 8 || imm_expr.X_add_number < 0)
+                    as_bad (_("(%d) is out of range 0-8"),
+                            (int) imm_expr.X_add_number);
+                  ip->insn_opcode |=
+                    ((imm_expr.X_add_number & OP_MASK_IMMIDATE74) <<
+                     OP_SH_IMMIDATE74);
+                  imm_expr.X_op = O_absent;
+                  s = expr_end;
+                  continue;
+                  /* 8 bits immediate ,used in lbp,stp,etc(OP_*_IMMIDATE88) */
+                case '~':
+                  my_getExpression (&imm_expr, s);
+                  check_absolute_expr (ip, &imm_expr);
+                  if ((strncmp (str, "lbp", 3) == 0)
+                      || (strncmp (str, "sbp", 3) == 0))
+                    multipletype = 0;
+                  else if ((strncmp (str, "lhp", 3) == 0)
+                           || (strncmp (str, "shp", 3) == 0))
+                    multipletype = 2;
+                  else if ((strncmp (str, "lwp", 3) == 0)
+                           || (strncmp (str, "swp", 3) == 0))
+                    multipletype = 4;
+                  else
+                    multipletype = 8;
+
+                  switch (multipletype)
+                    {
+                    case 0:
+                      if (((imm_expr.X_add_number + 128) & ~0xff) != 0)
+                        as_bad (_("(%d) is too large to fit in 8 bits"),
+                                (int) imm_expr.X_add_number);
+                      break;
+
+                    case 2:
+                      if ((imm_expr.X_add_number % 2) != 0)
+                        as_bad (_("(%d) is not multiple of 2"),
+                                (int) imm_expr.X_add_number);
+                      if (((imm_expr.X_add_number + 256) & ~0x1FF) != 0)
+                        as_bad (_("(%d) is too large to fit in 8 bits"),
+                                (int) imm_expr.X_add_number);
+                      imm_expr.X_add_number = imm_expr.X_add_number >> 1;
+                      break;
+
+                    case 4:
+                      if ((imm_expr.X_add_number % 4) != 0)
+                        as_bad (_("(%d) is not multiple of 4"),
+                                (int) imm_expr.X_add_number);
+
+                      if (((imm_expr.X_add_number + 512) & ~0x3FF) != 0)
+                        as_bad (_("(%d) is too large to fit in 8 bits"),
+                                (int) imm_expr.X_add_number);
+                      imm_expr.X_add_number = imm_expr.X_add_number >> 2;
+                      break;
+
+                    case 8:
+                      if ((imm_expr.X_add_number % 8) != 0)
+                        as_bad (_("(%d) is not multiple of 8"),
+                                (int) imm_expr.X_add_number);
+
+                      if (((imm_expr.X_add_number + 1024) & ~0x7FF) != 0)
+                        as_bad (_("(%d) is too large to fit in 8 bits"),
+                                (int) imm_expr.X_add_number);
+
+                      imm_expr.X_add_number = imm_expr.X_add_number >> 3;
+                      break;
+                    }
+                  ip->insn_opcode |=
+                    ((imm_expr.
+                      X_add_number & OP_MASK_IMMIDATE88) << OP_SH_IMMIDATE88);
+                  imm_expr.X_op = O_absent;
+                  s = expr_end;
+                  continue;
+
+                  /* even register,used in lt,st,ltp,stp (OP_*_EVENREG) */
+                case '`':
+                  if (s[0] == '$')
+                    {
+                      regno = 0;
+                      if (ISDIGIT (s[1]))
+                        {
+	                      ++s;
+                          do
+                            {
+                              regno *= 10;
+                              regno += *s - '0';
+                              ++s;
+                            }
+                          while (ISDIGIT (*s));
+
+                        }
+                      else if ((s[1] == 'f') && (s[2] == 'p'))
+                        {
+                          regno = 30;
+                          s += 3;
+                        }
+                      else if ((s[1] == 'a') && (s[2] == 't'))
+                        {
+                          regno = 1;
+                          s += 3;
+                        }
+                      else
+                        {
+                          insn_error = "register needed!";
+                          return;
+                        }
+                    }
+                  else
+                    {
+                      insn_error = "register needed!";
+                      return;
+                    }
+
+                  if (regno > 31)
+                    as_bad (_("invalid register number (%d)"), regno);
+
+                  if (regno % 2 != 0)
+                    as_bad (_("not an even register number(%d) "), regno);
+
+                  ip->insn_opcode |=
+                    (regno & OP_MASK_EVENREG) << OP_SH_EVENREG;
+                  continue;
+
+                case 'H':
+                  if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+                    s += 2;
+                  if (ISDIGIT (*s))
+                    {
+                      c = 0;
+                      do
+                 {
+                          c *= 10;
+                          c += *s - '0';
+                          ++s;
+                        }
+                      while (ISDIGIT (*s));
+                    }
+                  else
+                    c = 64;     /* Invalid sel or stype value. */
+
+                  if (c > 63)
+                    as_bad (_("invalid coprocessor sel value (0-63)"));
+
+                  ip->insn_opcode |= (c & OP_MASK_RLX_SEL) << OP_SH_RLX_SEL;
+                  continue;
+
+                case 'I':
+                  if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+                    s += 2;
+
+                  if (ISDIGIT (*s))
+                    {
+                      c = 0;
+                      do
+                        {
+                          c *= 10;
+                          c += *s - '0';
+                          ++s;
+                        }
+                      while (ISDIGIT (*s));
+                    }
+                  else
+                    c = 64;     /* Invalid sel value.  */
+
+                  if (c > 63)
+                    as_bad (_("invalid coprocessor stype value (0-63)"));
+
+                  ip->insn_opcode |=
+                    (c & OP_MASK_RLX_STYPE) << OP_SH_RLX_STYPE;
+                  continue;
+                }
+              break;
+
 	    case 'y':		/* ALNV.PS source register.  */
 	      gas_assert (mips_opts.micromips);
 	      goto do_reg;
@@ -11824,6 +12316,13 @@ mips_ip (char *str, struct mips_cl_insn
 		    {
 		    case 'r':
 		    case 's':
+                      if (strncmp (ip->insn_mo->name, "addma", 5) == 0
+                          || strncmp (ip->insn_mo->name, "subma", 5) == 0)
+                        {
+                          if ((regno & 3) == 0 || (regno & 3) == 3)
+                            as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                    str);
+                        }
 		    case 'v':
 		    case 'b':
 		      INSERT_OPERAND (mips_opts.micromips, RS, *ip, regno);
@@ -11837,6 +12336,42 @@ mips_ip (char *str, struct mips_cl_insn
 		      break;
 
 		    case 'd':
+                      if (strncmp (ip->insn_mo->name, "addma", 5) == 0
+                          || strncmp (ip->insn_mo->name, "subma", 5) == 0)
+                        {
+                          if (((regno & 3) == 0) || ((regno & 3) == 3))
+                            as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                    str);
+                        }
+
+                      if (strncmp (ip->insn_mo->name, "diva", 4) == 0
+                          || (strlen (ip->insn_mo->name) == 5
+                              && strncmp (ip->insn_mo->name, "multa", 5) == 0)
+                          || strncmp (ip->insn_mo->name, "multau", 6) == 0
+                          || strncmp (ip->insn_mo->name, "cmulta", 6) == 0
+                          || (strlen (ip->insn_mo->name) == 5
+                              && strncmp (ip->insn_mo->name, "madda", 5) == 0)
+                          || strncmp (ip->insn_mo->name, "maddau", 6) == 0
+                          || (strlen (ip->insn_mo->name) == 5
+                              && strncmp (ip->insn_mo->name, "msuba", 5) == 0)
+                          || strncmp (ip->insn_mo->name, "msubau", 6) == 0)
+                        {
+                          if ((regno & 3) != 3)
+                            as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                    str);
+                        }
+
+                      if (strncmp (ip->insn_mo->name, "multa2", 6) == 0
+                          || strncmp (ip->insn_mo->name, "mulna2", 6) == 0
+                          || strncmp (ip->insn_mo->name, "rnadda2", 6) == 0
+                          || strncmp (ip->insn_mo->name, "msuba2", 6) == 0
+                          || strncmp (ip->insn_mo->name, "mta2", 4) == 0)
+                        {
+                          if ((regno & 3) == 0)
+                            as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                    str);
+                        }
+
 		    case 'g':
 		      INSERT_OPERAND (mips_opts.micromips, RD, *ip, regno);
 		      break;
@@ -11849,6 +12384,25 @@ mips_ip (char *str, struct mips_cl_insn
 
 		    case 'w':
 		    case 't':
+                      if (strncmp (ip->insn_mo->name, "addma", 5) == 0 ||
+                          strncmp (ip->insn_mo->name, "subma", 5) == 0 ||
+                          strncmp (ip->insn_mo->name, "mfa",
+                                   strlen (ip->insn_mo->name)) == 0)
+                        {
+                          if (((regno & 3) == 0) || ((regno & 3) == 3))
+                            as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                    str);
+                        }
+
+                      if (strncmp (ip->insn_mo->name, "mfa2", 4) == 0)
+                        if ((regno & 3) != 3)
+                          as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                  str);
+
+                      if (strncmp (ip->insn_mo->name, "rnda2", 5) == 0)
+                        if ((regno & 3) == 0)
+                          as_bad (_("Illegal reg number (%d) in %s"), regno,
+                                  str);
 		    case 'E':
 		      INSERT_OPERAND (mips_opts.micromips, RT, *ip, regno);
 		      break;
@@ -15011,6 +15565,9 @@ mips_after_parse_args (void)
   if (mips_arch_string != 0)
     arch_info = mips_parse_cpu ("-march", mips_arch_string);
 
+  if (mips_tune_string != 0)
+    mips_set_architecture (mips_parse_cpu ("-mtune", mips_tune_string));
+
   if (file_mips_isa != ISA_UNKNOWN)
     {
       /* Handle -mipsN.  At this point, file_mips_isa contains the
@@ -15661,6 +16218,40 @@ md_apply_fix (fixS *fixP, valueT *valP,
       fixP->fx_done = 0;
       break;
 
+    case BFD_RELOC_OFF6A:
+      if (fixP->fx_done)
+        {
+          valueT tmp_value;
+          valueT org_value;
+
+          buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
+          tmp_value =
+            *(valueT *) (fixP->fx_frag->fr_literal + fixP->fx_where);
+          org_value = *valP;
+
+          if (target_big_endian)
+            {
+              tmp_value =
+                (((tmp_value & 0xff) << 24) |
+                 ((tmp_value & 0xff00) << 8) |
+                 (((tmp_value & 0xff0000) >> 8)) |
+                 (((tmp_value & 0xff000000) >> 24)));
+            }
+
+          if ((org_value % 8) != 0)
+            as_bad (_("(%d) is not multiple of 8"), (int) org_value);
+
+          if ((org_value & ~0x1FFF) != 0)
+            as_bad (_("(%d) is too large to stay in 13 bits"),
+                    (int) org_value);
+
+          tmp_value |=
+            (((org_value >> 3) & OP_MASK_OFFSET6A) << OP_SH_OFFSET6A);
+          md_number_to_chars ((char *) buf, tmp_value, 4);
+        }
+      break;
+
+
     default:
       internalError ();
     }
@@ -19042,6 +19633,12 @@ static const struct mips_cpu_info mips_c
   { "r3000",          0,			ISA_MIPS1,      CPU_R3000 },
   { "r2000",          0,			ISA_MIPS1,      CPU_R3000 },
   { "r3900",          0,			ISA_MIPS1,      CPU_R3900 },
+  {"lx4180",	      0,			ISA_MIPS1,	CPU_LX4180},
+  {"rlx4181",	      0,			ISA_MIPS1,	CPU_RLX4181},
+  {"rlx4281",	      0,			ISA_MIPS1,	CPU_RLX4281},
+  {"rlx5181",	      0,			ISA_MIPS1,	CPU_RLX5181},
+  {"lx5280",	      0,			ISA_MIPS1,	CPU_LX5280},
+  {"rlx5281",	      0,			ISA_MIPS1,	CPU_RLX5281},
 
   /* MIPS II */
   { "r6000",          0,			ISA_MIPS2,      CPU_R6000 },
@@ -19220,14 +19817,28 @@ mips_matching_cpu_name_p (const char *ca
 
   /* If not, try comparing based on numerical designation alone.
      See if GIVEN is an unadorned number, or 'r' followed by a number.  */
-  if (TOLOWER (*given) == 'r')
+
+  /* 2006-01-19 tonywu: add to parse LX/RLX CPUs */
+  if (TOLOWER (given[0]) == 'l' && TOLOWER (given[1]) == 'x')
+    given += 2;
+  else if (TOLOWER (given[0]) == 'r' &&
+           TOLOWER (given[1]) == 'l' && TOLOWER (given[2]) == 'x')
+    given += 3;
+  else if (TOLOWER (*given) == 'r')
     given++;
+
   if (!ISDIGIT (*given))
     return FALSE;
 
   /* Skip over some well-known prefixes in the canonical name,
      hoping to find a number there too.  */
-  if (TOLOWER (canonical[0]) == 'v' && TOLOWER (canonical[1]) == 'r')
+  /* 2006-01-19 tonywu: add to parse LX/RLX CPUs */
+  if (TOLOWER (canonical[0]) == 'l' && TOLOWER (canonical[1]) == 'x')
+    canonical += 2;
+  else if (TOLOWER (canonical[0]) == 'r' &&
+           TOLOWER (canonical[1]) == 'l' && TOLOWER (canonical[2]) == 'x')
+    canonical += 3;
+  else if (TOLOWER (canonical[0]) == 'v' && TOLOWER (canonical[1]) == 'r')
     canonical += 2;
   else if (TOLOWER (canonical[0]) == 'r' && TOLOWER (canonical[1]) == 'm')
     canonical += 2;
@@ -19496,3 +20107,83 @@ tc_mips_regname_to_dw2regnum (char *regn
 
   return regnum;
 }
+
+static inline int
+rlx_is_insn_lt (const struct mips_cl_insn *insn1,
+                const struct mips_cl_insn *insn2)
+{
+  int is_lt = 0;
+
+  if (insn1 == NULL || insn2 == NULL)
+    return 0;
+
+  if (strncmp (insn1->insn_mo->name, "lt", 2) == 0)
+    is_lt = 1;
+  else if (strncmp (insn1->insn_mo->name, "ltw", 3) == 0)
+    is_lt = 1;
+
+  if (is_lt == 0)
+    return 0;
+
+  int regno1 = gpr_write_mask (insn1); 
+  int regno2 = regno1 + 1;
+
+  if ((gpr_read_mask (insn2) & regno1) ||
+	(gpr_read_mask (insn2) & regno2))	
+    return 1;
+
+  return 0;
+}
+
+static inline int
+rlx_is_insn_st (const struct mips_cl_insn *insn1,
+                const struct mips_cl_insn *insn2)
+{
+  int is_st = 0;
+
+  if (insn1 == NULL || insn2 == NULL)
+    return 0;
+
+  if (strncmp (insn2->insn_mo->name, "st", 2) == 0)
+    is_st = 1;
+
+  if (is_st == 0)
+    return 0;
+
+  int regno1 = gpr_write_mask(insn1);
+  int regno2 = 0;
+
+  if (regno1 % 2 == 0)
+    regno2 = regno1 + 1;
+  else
+    regno2 = regno1 - 1;
+
+  if ((gpr_read_mask(insn2) & regno1) ||
+	gpr_read_mask(insn2) & regno2)
+    return 1;
+
+  return 0;
+}
+
+/* 2006-01-05 tonywu: merged from 2.14 */
+static inline int
+rlx_nops_for_new_insn (const struct mips_cl_insn *pre,
+                       const struct mips_cl_insn *now)
+{
+  if ((pre == NULL) || (now == NULL))
+    return 0;
+
+  if ((pre->insn_mo->match == 0 && pre->insn_mo->mask == 0xffffffff) ||
+      (now->insn_mo->match == 0 && now->insn_mo->mask == 0xffffffff))
+    return 0;
+
+  if (pre->insn_mo == &dummy_opcode || now->insn_mo == &dummy_opcode)
+    return 0;
+
+  if (strcmp (pre->insn_mo->name, "madda") == 0 &&
+      strcmp (now->insn_mo->name, "mfa") == 0 &&
+      EXTRACT_OPERAND (0, RD, *pre) == EXTRACT_OPERAND (0, RT, *now))
+    return 2;
+
+  return 0;
+}
diff -Naurp binutils-2.23.1/gas/write.c binutils-2.23.1.new/gas/write.c
--- binutils-2.23.1/gas/write.c	2012-07-02 10:35:06.000000000 +0300
+++ binutils-2.23.1.new/gas/write.c	2017-08-25 21:17:46.032922530 +0300
@@ -1170,6 +1170,9 @@ install_reloc (asection *sec, arelent *r
     case bfd_reloc_outofrange:
       as_bad_where (file, line, _("relocation out of range"));
       break;
+    case bfd_reloc_notmultipleof8_ltw:
+      as_bad_where (file, line, _("offset in ltw instruction is not multiple of 8"));
+      break;
     default:
       as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
 		file, line, s);
diff -Naurp binutils-2.23.1/include/elf/mips.h binutils-2.23.1.new/include/elf/mips.h
--- binutils-2.23.1/include/elf/mips.h	2011-12-19 09:58:02.000000000 +0200
+++ binutils-2.23.1.new/include/elf/mips.h	2017-08-25 21:17:46.032922530 +0300
@@ -89,7 +89,8 @@ START_RELOC_NUMBERS (elf_mips_reloc_type
   RELOC_NUMBER (R_MIPS_TLS_TPREL_HI16, 49)
   RELOC_NUMBER (R_MIPS_TLS_TPREL_LO16, 50)
   RELOC_NUMBER (R_MIPS_GLOB_DAT, 51)
-  FAKE_RELOC (R_MIPS_max, 52)
+  RELOC_NUMBER (R_RELOC_OFF6A, 52)
+  FAKE_RELOC (R_MIPS_max, 53)
   /* These relocs are used for the mips16.  */
   FAKE_RELOC (R_MIPS16_min, 100)
   RELOC_NUMBER (R_MIPS16_26, 100)
diff -Naurp binutils-2.23.1/include/opcode/mips.h binutils-2.23.1.new/include/opcode/mips.h
--- binutils-2.23.1/include/opcode/mips.h	2012-09-04 17:21:05.000000000 +0300
+++ binutils-2.23.1.new/include/opcode/mips.h	2017-08-26 01:30:23.754362473 +0300
@@ -61,6 +61,22 @@
 
    The general coprocessor instructions use COPZ.  */
 
+#define OP_MASK_IMMIDATE74	0xf		/* used in MFA,MFA2,RNDA2 */
+#define OP_SH_IMMIDATE74	7		/* used in MFA,MFA2,RNDA2 */
+#define OP_MASK_IMMIDATE6b	0x7ff		/* used in lt,st */
+#define OP_SH_IMMIDATE6b	6		/* used in lt,st */
+#define OP_MASK_IMMIDATE88	0xff		/* used in lbp,stp,etc */
+#define OP_SH_IMMIDATE88	8		/* used in lbp,stp,etc */
+#define OP_MASK_EVENREG		0x1f		/* used in lt,st,ltp,stp */
+#define OP_SH_EVENREG		16		/* used in lt,st,ltp,stp */
+#define OP_MASK_OFFSET6A	0x3ff		/* used in ltw */
+#define OP_SH_OFFSET6A		6		/* used in ltw */
+
+#define OP_MASK_RLX_SEL		0x3f
+#define OP_SH_RLX_SEL		0
+#define OP_MASK_RLX_STYPE	0x3f
+#define OP_SH_RLX_STYPE		6
+
 #define OP_MASK_OP		0x3f
 #define OP_SH_OP		26
 #define OP_MASK_RS		0x1f
@@ -380,6 +396,13 @@ struct mips_opcode
    "j" 16 bit signed immediate (OP_*_DELTA)
    "k" 5 bit cache opcode in target register position (OP_*_CACHE)
        Also used for immediate operands in vr5400 vector insns.
+*********************** dbb  modified for supporting radiax instructions **************************
+   "@" 11 bits immediate used in lt,st (OP_*_IMMIDATE6b),in fact it is 14 bits,mutiple of 8;
+   "#" 4 bits immediate from 0 to 8,used in MFA,MFA2,RNDA2 (OP_*_IMMIDATE74)
+   "~" 8 bits immediate ,used in lbp,stp,etc(OP_*_IMMIDATE88)
+   "`"  even register,used in lt,st,ltp,stp (OP_*_EVENREG)
+   "-"  10 bits offset,used in ltw(OP_*_OFFSET6A)
+*********************** dbb  modified for supporting radiax instructions **************************
    "o" 16 bit signed offset (OP_*_DELTA)
    "p" 16 bit PC relative branch target address (OP_*_DELTA)
    "q" 10 bit extra breakpoint code (OP_*_CODE2)
@@ -749,15 +772,18 @@ static const unsigned int mips_isa_table
 #define INSN_10000                0x00100000
 /* Broadcom SB-1 instruction.  */
 #define INSN_SB1                  0x00200000
+
 /* NEC VR4111/VR4181 instruction.  */
 #define INSN_4111                 0x00400000
 /* NEC VR4120 instruction.  */
 #define INSN_4120                 0x00800000
+
+
+#if 0 //JMM - break all these badly sorry!
 /* NEC VR5400 instruction.  */
 #define INSN_5400		  0x01000000
 /* NEC VR5500 instruction.  */
 #define INSN_5500		  0x02000000
-
 /* MDMX ASE */ 
 #define INSN_MDMX                 0x04000000
 /* MT ASE */
@@ -770,6 +796,34 @@ static const unsigned int mips_isa_table
 #define INSN_LOONGSON_2E          0x40000000
 /* ST Microelectronics Loongson 2F.  */
 #define INSN_LOONGSON_2F          0x80000000
+#else
+
+#define INSN_4180                 0x01000000
+#define INSN_4181                 0x02000000
+#define INSN_4281                 0x04000000
+#define INSN_5181                 0x08000000
+#define INSN_5280                 0x10000000
+#define INSN_5281                 0x20000000
+
+#define INSN_DONT_CARE           0x80000000
+/* NEC VR5400 instruction.  */
+#define INSN_5400                INSN_DONT_CARE
+/* NEC VR5500 instruction.  */
+#define INSN_5500                INSN_DONT_CARE
+/* MDMX ASE */
+#define INSN_MDMX                 INSN_DONT_CARE
+/* MT ASE */
+#define INSN_MT                   INSN_DONT_CARE
+/* SmartMIPS ASE  */
+#define INSN_SMARTMIPS            INSN_DONT_CARE
+/* DSP R2 ASE  */
+#define INSN_DSPR2                INSN_DONT_CARE
+/* ST Microelectronics Loongson 2E.  */
+#define INSN_LOONGSON_2E          INSN_DONT_CARE
+/* ST Microelectronics Loongson 2F.  */
+#define INSN_LOONGSON_2F          INSN_DONT_CARE
+#endif
+
 /* Loongson 3A.  */
 #define INSN_LOONGSON_3A          0x00000400
 /* RMI Xlr instruction */
@@ -804,11 +858,17 @@ static const unsigned int mips_isa_table
 #define CPU_VR4100	4100
 #define CPU_R4111	4111
 #define CPU_VR4120	4120
+#define CPU_LX4180	4180    /*  LX4180 */
+#define CPU_RLX4181	4181    /* RLX4181 */
+#define CPU_RLX4281	4281    /* RLX4281 */
 #define CPU_R4300	4300
 #define CPU_R4400	4400
 #define CPU_R4600	4600
 #define CPU_R4650	4650
 #define CPU_R5000	5000
+#define CPU_RLX5181	5181    /* RLX5181 */
+#define CPU_RLX5281	5281    /* RLX5281 */
+#define CPU_LX5280	5280    /*  LX5280 */
 #define CPU_VR5400	5400
 #define CPU_VR5500	5500
 #define CPU_R6000	6000
@@ -870,6 +930,24 @@ cpu_is_member (int cpu, unsigned int mas
     case CPU_VR4120:
       return (mask & INSN_4120) != 0;
 
+    case CPU_LX4180:
+      return (mask & INSN_4180) != 0;
+
+    case CPU_RLX4181:
+      return (mask & INSN_4181) != 0;
+
+    case CPU_RLX4281:
+      return (mask & INSN_4281) != 0;
+
+    case CPU_RLX5181:
+      return (mask & INSN_5181) != 0;
+
+    case CPU_LX5280:
+      return (mask & INSN_5280) != 0;
+
+    case CPU_RLX5281:
+      return (mask & INSN_5281) != 0;
+
     case CPU_VR5400:
       return (mask & INSN_5400) != 0;
 
diff -Naurp binutils-2.23.1/opcodes/mips16-opc.c binutils-2.23.1.new/opcodes/mips16-opc.c
--- binutils-2.23.1/opcodes/mips16-opc.c	2012-05-17 18:13:25.000000000 +0300
+++ binutils-2.23.1.new/opcodes/mips16-opc.c	2017-08-25 21:17:46.040920837 +0300
@@ -67,6 +67,11 @@
 #define I64	INSN_ISA64
 #define T3	INSN_3900
 
+#define RLX1    INSN_4180 | INSN_4181 | INSN_4281 | INSN_5181 | INSN_5280 | INSN_5281
+#define RLX2    INSN_4181 | INSN_4281 | INSN_5181 | INSN_5280 | INSN_5281
+#define RLX3    INSN_4181 | INSN_4281 | INSN_5181 | INSN_5281
+#define RLX4    INSN_5181 | INSN_5280 | INSN_5281
+
 const struct mips_opcode mips16_opcodes[] =
 {
 /* name,    args,	match,	mask,	pinfo,         	pinfo2, membership */
@@ -111,6 +116,7 @@ const struct mips_opcode mips16_opcodes[
 {"bne",     "x,U,p",	0, (int) M_BNE_I, INSN_MACRO,	0,	I1 },
 {"bnez",    "x,p",	0x2800, 0xf800, CBR|RD_x,	0,	I1 },
 {"break",   "6",	0xe805, 0xf81f, TRAP,		0,	I1 },
+{"break",   "",		0xe805, 0xffff, TRAP,		0,	RLX1},
 {"bteqz",   "p",	0x6000, 0xff00, CBR|RD_T,	0,	I1 },
 {"btnez",   "p",	0x6100, 0xff00, CBR|RD_T,	0,	I1 },
 {"cmpi",    "x,U",	0x7000, 0xf800, WR_T|RD_x,	0,	I1 },
@@ -193,10 +199,18 @@ const struct mips_opcode mips16_opcodes[
 {"lw",	    "x,V(P)",	0xb000, 0xf800, WR_x|RD_PC,	0,	I1 },
 {"lw",	    "x,V(S)",	0x9000, 0xf800, WR_x|RD_SP,	0,	I1 },
 {"lwu",     "y,W(x)",	0xb800, 0xf800, WR_y|RD_x, 	0,	I3 },
+{"madh",    "x,y", 	0xf800, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"madl",    "x,y", 	0xf802, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"mazh",    "x,y", 	0xf804, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"mazl",    "x,y", 	0xf806, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
 {"mfhi",    "x",	0xe810, 0xf8ff, WR_x|RD_HI,	0,	I1 },
 {"mflo",    "x",	0xe812, 0xf8ff, WR_x|RD_LO,	0,	I1 },
 {"move",    "y,X",	0x6700, 0xff00, WR_y|RD_X, 	0,	I1 },
 {"move",    "Y,Z",	0x6500, 0xff00, WR_Y|RD_Z,	0,	I1 },
+{"msbh",    "x,y", 	0xf810, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"msbl",    "x,y",	0xf812, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"mszh",    "x,y",	0xf814, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
+{"mszl",    "x,y", 	0xf816, 0xf81f, RD_x|RD_y|WR_HI|WR_LO, 0, RLX1},
 {"mul",     "z,v,y",	0, (int) M_MUL, INSN_MACRO,	0,	I1 },
 {"mult",    "x,y",	0xe818, 0xf81f, RD_x|RD_y|WR_HI|WR_LO,	0,	I1 },
 {"multu",   "x,y",	0xe819, 0xf81f, RD_x|RD_y|WR_HI|WR_LO,	0,	I1 },
diff -Naurp binutils-2.23.1/opcodes/mips-dis.c binutils-2.23.1.new/opcodes/mips-dis.c
--- binutils-2.23.1/opcodes/mips-dis.c	2012-09-04 17:23:13.000000000 +0300
+++ binutils-2.23.1.new/opcodes/mips-dis.c	2017-08-26 19:53:07.844952977 +0300
@@ -32,6 +32,28 @@
    symbol table is available when this code runs out in an embedded
    system as when it is used for disassembler support in a monitor.  */
 
+int is_rlx_insn = 0;
+int des_reg_type = 0;
+/* the des reg is:
+ * 0 gr,
+ * 1 accumulator,
+ * 2 Radiax User register,
+ * 3 Selects Lexra Coprocessor0 register
+ */
+int src_reg_type = 0;
+/* the src reg is:
+ * 0 gr,
+ * 1 accumulator,
+ * 2 Radiax User register
+ */
+int targ_reg_type = 0;
+/* the target reg is:
+ * 0 gr,
+ * 1 accumulator,
+ * 2 Radiax User register
+ */
+
+
 #if !defined(EMBEDDED_ENV)
 #define SYMTAB_AVAILABLE 1
 #include "elf-bfd.h"
@@ -169,6 +191,16 @@ static const char * const mips_gpr_names
   "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
 };
 
+static const char *const mips_accumulator_names_alias[16] = {
+  "reserve", "m0l", "m0h", "m0", "reserve", "m1l", "m1h", "m1",
+  "reserve", "m2l", "m2h", "m2", "reserve", "m3l", "m3h", "m3"
+};
+
+static const char *const mips_radreg_names_alias[14] = {
+  "cbs0", "cbs1", "cbs2", "reserved", "cbe0", "cbe1", "cbe2", "reserved",
+  "lps0", "lpe0", "lpc0", "reserved", "mmd", "reserved"
+};
+
 static const char * const mips_fpr_names_numeric[32] =
 {
   "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
@@ -518,6 +550,12 @@ const struct mips_arch_choice mips_arch_
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "vr4120",	1, bfd_mach_mips4120, CPU_VR4120, ISA_MIPS3,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
+  { "4180",	1, bfd_mach_mips4180, CPU_LX4180, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
+  { "4181",	1, bfd_mach_mips4181, CPU_RLX4181, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
+  { "4281",	1, bfd_mach_mips4281, CPU_RLX4281, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
   { "r4300",	1, bfd_mach_mips4300, CPU_R4300, ISA_MIPS3,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "r4400",	1, bfd_mach_mips4400, CPU_R4400, ISA_MIPS3,
@@ -528,6 +566,12 @@ const struct mips_arch_choice mips_arch_
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "r5000",	1, bfd_mach_mips5000, CPU_R5000, ISA_MIPS4,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
+  { "5181", 	1, bfd_mach_mips5181, CPU_RLX5181, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
+  { "5281", 	1, bfd_mach_mips5281, CPU_RLX5281, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
+  { "5280", 	1, bfd_mach_mips5280, CPU_LX5280, ISA_MIPS1,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric},
   { "vr5400",	1, bfd_mach_mips5400, CPU_VR5400, ISA_MIPS4,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "vr5500",	1, bfd_mach_mips5500, CPU_VR5500, ISA_MIPS4,
@@ -1158,7 +1202,12 @@ print_insn_args (const char *d,
 	  break;
 
 	case '~':
-	  infprintf (is, "%d", GET_OP_S (l, OFFSET12));
+	  if (is_rlx_insn)
+	    /* Radiax: 8 bits immediate, in lbp,stp,etc(OP_*_IMMIDATE88) */
+	    infprintf (is, "%i", GET_OP_S (l, IMMIDATE88));
+	  else
+	    /* MCU ASE: 12 bit offset (OP_*_OFFSET12)  */
+	    infprintf (is, "%d", GET_OP_S (l, OFFSET12));
 	  break;
 
 	case '\\':
@@ -1198,12 +1247,18 @@ print_insn_args (const char *d,
 	case 'b':
 	case 'r':
 	case 'v':
-	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RS)]);
+	  if (src_reg_type == 1)
+	    infprintf (is, "%s", mips_accumulator_names_alias[GET_OP (l, RS)]);
+	  else
+	    infprintf (is, "%s", mips_gpr_names[GET_OP (l, RS)]);
 	  break;
 
 	case 't':
 	case 'w':
-	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
+	  if (targ_reg_type == 1)
+	    infprintf (is, "%s", mips_accumulator_names_alias[GET_OP (l, RT)]);
+	  else 
+	    infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
 	  break;
 
 	case 'i':
@@ -1241,7 +1296,41 @@ print_insn_args (const char *d,
 	  break;
 
 	case 'd':
-	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RD)]);
+	  switch(des_reg_type) {
+//	    int tmp_regno = GET_OP(l, RD);
+	    case 1:
+	      op = GET_OP(l, RD);
+	      if (op >= 16 || op < 0)
+		infprintf (is, "INVALID");
+	      else
+		infprintf (is, "%s", mips_accumulator_names_alias[op]);
+	      break;
+	    case 2:
+	      op = GET_OP(l, RD);
+	      if (op <= 7)
+		infprintf (is, "%s", mips_radreg_names_alias[op]);
+	      else if ((16 <= op) && (op <= 19))
+		infprintf (is, "%s", mips_radreg_names_alias[op - 8]);
+	      else if (op == 24)
+		infprintf (is, "%s", mips_radreg_names_alias[12]);
+	      else
+		infprintf (is, "%s", mips_radreg_names_alias[13]);
+	      break;
+	    case 3:
+	      op = GET_OP(l, RD);
+	      if (op == 0)
+		infprintf (is, "estatus");
+	      else if (op == 1)
+		infprintf (is, "ecause");
+	      else if (op == 2)
+		infprintf (is, "intvec");
+	      else
+		infprintf (is, "reserved");
+	      break;
+	    default:
+	      infprintf (is, "%s", mips_gpr_names[GET_OP (l, RD)]);
+	      break;
+	  }
 	  break;
 
 	case 'U':
@@ -1406,6 +1495,28 @@ print_insn_args (const char *d,
 	  infprintf (is, "$v%d", GET_OP (l, FT));
 	  break;
 
+	case '#':
+	  infprintf (is, "%i", GET_OP (l, IMMIDATE74));
+	  break;
+
+	  /* even register,used in lt,st,ltp,stp (OP_*_EVENREG) */
+	case '`':
+	  op = GET_OP_S (l, EVENREG);
+	  if ((op % 2) != 0)
+	    op--;            /* for "lt" insn */
+	  infprintf (is, "%s", mips_gpr_names[op]);
+	  break;
+
+	  /* 10 bits offset,used in ltw(OP_*_OFFSET6A) */
+	case '-':
+//          delta = GET_OP_S (l, OFFSET6A);
+//          if (delta & 0x200)
+//            delta |= ~0x3ff;
+          /* 2006-02-08 tonywu: fix ltw objdump displacement */
+//          delta <<= 3;
+	  infprintf (is, "%d", GET_OP_S (l, OFFSET6A) << 3);
+	  break;
+
 	default:
 	  /* xgettext:c-format */
 	  infprintf (is, _("# internal error, undefined modifier (%c)"), *d);
@@ -1504,6 +1615,80 @@ print_insn_mips (bfd_vma memaddr,
 	      infprintf (is, "%s", op->name);
 
 	      d = op->args;
+
+              des_reg_type = 0;
+              src_reg_type = 0;
+              targ_reg_type = 0;
+
+              if ((op->membership & INSN_4181) ||
+                  (op->membership & INSN_4281) ||
+                  (op->membership & INSN_5181) ||
+                  (op->membership & INSN_5281) ||
+                  (op->membership & INSN_5280))
+                {
+                  is_rlx_insn = 1;
+                  if (strncmp (op->name, "mta2", 4) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if ((strncmp (op->name, "mflxc0", 6) == 0)
+                           || (strncmp (op->name, "mtlxc0", 6) == 0))
+                    {
+                      des_reg_type = 3;
+                    }
+                  else if (strncmp (op->name, "mfa", 3) == 0)
+                    {
+                      targ_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "diva", 4) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "multa", 5) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "mulna2", 6) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "cmulta", 6) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "madda", 5) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "msuba", 5) == 0)
+                    {
+                      des_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "addma", 5) == 0)
+                    {
+                      des_reg_type = 1;
+                      src_reg_type = 1;
+                      targ_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "subma", 5) == 0)
+                    {
+                      des_reg_type = 1;
+                      src_reg_type = 1;
+                      targ_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "rnda2", 5) == 0)
+                    {
+                      targ_reg_type = 1;
+                    }
+                  else if (strncmp (op->name, "mtru", 4) == 0)
+                    {
+                      des_reg_type = 2;
+                    }
+                  else if (strncmp (op->name, "mfru", 4) == 0)
+                    {
+                      des_reg_type = 2;
+                    }
+                }
 	      if (d != NULL && *d != '\0')
 		{
 		  infprintf (is, "\t");
diff -Naurp binutils-2.23.1/opcodes/mips-opc.c binutils-2.23.1.new/opcodes/mips-opc.c
--- binutils-2.23.1/opcodes/mips-opc.c	2012-09-04 17:21:10.000000000 +0300
+++ binutils-2.23.1.new/opcodes/mips-opc.c	2017-08-26 21:42:35.956768122 +0300
@@ -166,6 +166,18 @@
 #define D33	INSN_DSPR2
 #define D64	INSN_DSP64
 
+#define RLX0 INSN_4180
+#define RLX1 INSN_5280
+#define RLX2 INSN_4181|INSN_5181
+#define RLX3 INSN_4281|INSN_5281
+
+#define RLXA (RLX0|RLX1|RLX2|RLX3)
+#define RLXB (RLX1|RLX2|RLX3)
+
+#define RAD1 INSN_5181|INSN_5280|INSN_5281
+#define RAD2 INSN_5281
+
+
 /* MIPS MT ASE support.  */
 #define MT32	INSN_MT
 
@@ -202,7 +214,7 @@ const struct mips_opcode mips_builtin_op
 {"pref",    "k,A(b)",	0,    (int) M_PREF_AB,	INSN_MACRO,		0,		I4_32|G3	},
 {"prefx",   "h,t(b)",	0x4c00000f, 0xfc0007ff, RD_b|RD_t|FP_S,		0,		I4_33	},
 {"nop",     "",         0x00000000, 0xffffffff, 0,              	INSN2_ALIAS,	I1      }, /* sll */
-{"ssnop",   "",         0x00000040, 0xffffffff, 0,              	INSN2_ALIAS,	I1	}, /* sll */
+{"ssnop",   "",         0x00000040, 0xffffffff, 0,              	INSN2_ALIAS,	I1|RLX3	}, /* sll */
 {"ehb",     "",         0x000000c0, 0xffffffff, 0,              	INSN2_ALIAS,	I1	}, /* sll */
 {"li",      "t,j",      0x24000000, 0xffe00000, WR_t,			INSN2_ALIAS,	I1	}, /* addiu */
 {"li",	    "t,i",	0x34000000, 0xffe00000, WR_t,			INSN2_ALIAS,	I1	}, /* ori */
@@ -587,14 +599,16 @@ const struct mips_opcode mips_builtin_op
 {"flushd",  "",		0xbc020000, 0xffffffff, 0, 			0,		L1	},
 {"flushid", "",		0xbc030000, 0xffffffff, 0, 			0,		L1	},
 {"wb", 	    "o(b)",	0xbc040000, 0xfc1f0000, SM|RD_b,		0,		L1	},
-{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3_32|T3},
+{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3_32|T3|RLXB},
 {"cache",   "k,A(b)",	0,    (int) M_CACHE_AB, INSN_MACRO,		0,		I3_32|T3},
 {"ceil.l.d", "D,S",	0x4620000a, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3_33	},
 {"ceil.l.s", "D,S",	0x4600000a, 0xffff003f, WR_D|RD_S|FP_S|FP_D,	0,		I3_33	},
 {"ceil.w.d", "D,S",	0x4620000e, 0xffff003f, WR_D|RD_S|FP_S|FP_D,	0,		I2	},
 {"ceil.w.s", "D,S",	0x4600000e, 0xffff003f, WR_D|RD_S|FP_S,		0,		I2	},
 {"cfc0",    "t,G",	0x40400000, 0xffe007ff,	LCD|WR_t|RD_C0,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cfc0",    "t,G,#H",	0x40400000, 0xffe007c0, LCD|WR_t|RD_C0,		0,		RLX3	},
 {"cfc1",    "t,G",	0x44400000, 0xffe007ff,	LCD|WR_t|RD_C1|FP_S,	0,		I1	},
+{"cfc1",    "t,G,#H",	0x44400000, 0xffe007c0, LCD|WR_t|RD_C1|FP_S,	0,		RLX3	},
 {"cfc1",    "t,S",	0x44400000, 0xffe007ff,	LCD|WR_t|RD_C1|FP_S,	0,		I1	},
 /* cfc2 is at the bottom of the table.  */
 /* cfc3 is at the bottom of the table.  */
@@ -607,7 +621,9 @@ const struct mips_opcode mips_builtin_op
 {"clo",     "U,s",      0x70000021, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
 {"clz",     "U,s",      0x70000020, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
 {"ctc0",    "t,G",	0x40c00000, 0xffe007ff,	COD|RD_t|WR_CC,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"ctc0",    "t,G,#H",	0x40c00000, 0xffe007c0, COD|RD_t|WR_CC,		0,		RLX3	},
 {"ctc1",    "t,G",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
+{"ctc1",    "t,G,#H",	0x44c00000, 0xffe007c0, COD|RD_t|WR_CC|FP_S,	0,		RLX3	},
 {"ctc1",    "t,S",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
 /* ctc2 is at the bottom of the table.  */
 /* ctc3 is at the bottom of the table.  */
@@ -645,7 +661,7 @@ const struct mips_opcode mips_builtin_op
 /* dctr and dctw are used on the r5000.  */
 {"dctr",    "o(b)",	0xbc050000, 0xfc1f0000, RD_b,			0,		I3	},
 {"dctw",    "o(b)",	0xbc090000, 0xfc1f0000, RD_b,			0,		I3	},
-{"deret",   "",         0x4200001f, 0xffffffff, NODS, 			0,		I32|G2	},
+{"deret",   "",		0x4200001f, 0xffffffff, NODS, 			0,		I32|G2|RLXA	},
 {"dext",    "t,r,I,+I",	0,    (int) M_DEXT,	INSN_MACRO,		0,		I65	},
 {"dext",    "t,r,+A,+C", 0x7c000003, 0xfc00003f, WR_t|RD_s,    		0,		I65	},
 {"dextm",   "t,r,+A,+G", 0x7c000001, 0xfc00003f, WR_t|RD_s,    		0,		I65	},
@@ -876,8 +892,8 @@ const struct mips_opcode mips_builtin_op
 {"li.d",    "T,L",	0,    (int) M_LI_DD,	INSN_MACRO,		INSN2_M_FP_D,	I1	},
 {"li.s",    "t,f",	0,    (int) M_LI_S,	INSN_MACRO,		INSN2_M_FP_S,	I1	},
 {"li.s",    "T,l",	0,    (int) M_LI_SS,	INSN_MACRO,		INSN2_M_FP_S,	I1	},
-{"ll",	    "t,o(b)",	0xc0000000, 0xfc000000, LDD|RD_b|WR_t,		0,		I2	},
-{"ll",	    "t,A(b)",	0,    (int) M_LL_AB,	INSN_MACRO,		0,		I2	},
+{"ll",	    "t,o(b)",	0xc0000000, 0xfc000000, LDD|RD_b|WR_t,		0,		I2|RLX2|RLX3	},
+{"ll",	    "t,A(b)",	0,    (int) M_LL_AB,	INSN_MACRO,		0,		I2|RLX2|RLX3	},
 {"lld",	    "t,o(b)",	0xd0000000, 0xfc000000, LDD|RD_b|WR_t,		0,		I3	},
 {"lld",     "t,A(b)",	0,    (int) M_LLD_AB,	INSN_MACRO,		0,		I3	},
 {"lui",     "t,u",	0x3c000000, 0xffe00000,	WR_t,			0,		I1	},
@@ -921,8 +937,8 @@ const struct mips_opcode mips_builtin_op
 {"maccu",   "d,s,t",	0x00000068, 0xfc0007ff,	RD_s|RD_t|WR_HILO|WR_d, 0,		N412    },
 {"maccu",   "d,s,t",	0x00000159, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d,	0,		N5      },
 {"maccus",  "d,s,t",	0x00000468, 0xfc0007ff,	RD_s|RD_t|WR_HILO|WR_d, 0,		N412    },
-{"mad",     "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		P3      },
-{"madu",    "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		P3      },
+{"mad",     "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		P3|RLXA	},
+{"madu",    "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		P3|RLXA	},
 {"madd.d",  "D,R,S,T",	0x4c000021, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D,    0,		I4_33	},
 {"madd.d",	"D,S,T",	0x46200018,	0xffe0003f,	RD_S|RD_T|WR_D|FP_D,	0,	IL2E	},
 {"madd.d",	"D,S,T",	0x72200018,	0xffe0003f,	RD_S|RD_T|WR_D|FP_D,	0,	IL2F	},
@@ -970,10 +986,12 @@ const struct mips_opcode mips_builtin_op
 {"mftlo",   "d,*",	0x41000021, 0xfff307ff, TRAP|WR_d|RD_a,		0,		MT32	},
 {"mftr",    "d,t,!,H,$", 0x41000000, 0xffe007c8, TRAP|WR_d,		0,		MT32	},
 {"mfc0",    "t,G",	0x40000000, 0xffe007ff,	LCD|WR_t|RD_C0,		0,		I1	},
+{"mfc0",    "t,G,#H",	0x40000000, 0xffe007c0, LCD|WR_t|RD_C0,		0,		RLX3	},
 {"mfc0",    "t,+D",0x40000000, 0xffe007f8,	LCD|WR_t|RD_C0,		0,		I32	},
 {"mfc0",    "t,G,H",	0x40000000, 0xffe007f8,	LCD|WR_t|RD_C0,		0,		I32	},
 {"mfc1",    "t,S",	0x44000000, 0xffe007ff,	LCD|WR_t|RD_S|FP_S,	0,		I1	},
 {"mfc1",    "t,G",	0x44000000, 0xffe007ff,	LCD|WR_t|RD_S|FP_S,	0,		I1	},
+{"mfc1",    "t,G,#H", 	0x44000000, 0xffe007c0, LCD|WR_t|RD_S|FP_S,	0,		RLX3	},
 {"mfhc1",   "t,S",	0x44600000, 0xffe007ff,	LCD|WR_t|RD_S|FP_D,	0,		I33	},
 {"mfhc1",   "t,G",	0x44600000, 0xffe007ff,	LCD|WR_t|RD_S|FP_D,	0,		I33	},
 /* mfc2 is at the bottom of the table.  */
@@ -1001,7 +1019,7 @@ const struct mips_opcode mips_builtin_op
 {"movf.l",  "X,Y,N",	0x46a00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		MX|SB1	},
 {"movf.s",  "D,S,N",    0x46000011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4_32	},
 {"movf.ps", "D,S,N",	0x46c00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5_33	},
-{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4_32|IL2E|IL2F	},
+{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4_32|IL2E|IL2F|RLXB	},
 {"movnz",   "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		IL2E|IL2F|IL3A	},
 {"ffc",     "d,v",	0x0000000b, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movn.d",  "D,S,t",    0x46200013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4_32	},
@@ -1015,7 +1033,7 @@ const struct mips_opcode mips_builtin_op
 {"movt.l",  "X,Y,N",    0x46a10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,   0,		MX|SB1	},
 {"movt.s",  "D,S,N",    0x46010011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4_32	},
 {"movt.ps", "D,S,N",	0x46c10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5_33	},
-{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4_32|IL2E|IL2F	},
+{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4_32|IL2E|IL2F|RLXB	},
 {"ffs",     "d,v",	0x0000000a, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movz.d",  "D,S,t",    0x46200012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4_32	},
 {"movz.l",  "D,S,t",    0x46a00012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		MX|SB1	},
@@ -1043,17 +1061,19 @@ const struct mips_opcode mips_builtin_op
 {"msub.ps",	"D,S,T",	0x45600019,	0xffe0003f,	RD_S|RD_T|WR_D|FP_D,	0,	IL2E	},
 {"msub.ps",	"D,S,T",	0x71600019,	0xffe0003f,	RD_S|RD_T|WR_D|FP_D,	0,	IL2F	},
 {"msub",    "s,t",      0x0000001e, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1    	},
-{"msub",    "s,t",      0x70000004, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55 },
+{"msub",    "s,t",      0x70000004, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55|RLXA },
 {"msub",    "7,s,t",	0x70000004, 0xfc00e7ff, MOD_a|RD_s|RD_t,        0,              D32	},
 {"msubu",   "s,t",      0x0000001f, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1	},
-{"msubu",   "s,t",      0x70000005, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55	},
+{"msubu",   "s,t",      0x70000005, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55|RLXA	},
 {"msubu",   "7,s,t",	0x70000005, 0xfc00e7ff, MOD_a|RD_s|RD_t,        0,              D32	},
 {"mtpc",    "t,P",	0x4080c801, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
 {"mtps",    "t,P",	0x4080c800, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
 {"mtc0",    "t,G",	0x40800000, 0xffe007ff,	COD|RD_t|WR_C0|WR_CC,	0,		I1	},
+{"mtc0",    "t,G,#H",	0x40800000, 0xffe007c0, COD|RD_t|WR_C0|WR_CC,	0,		RLX3	},
 {"mtc0",    "t,+D",	0x40800000, 0xffe007f8,	COD|RD_t|WR_C0|WR_CC,	0,		I32	},
 {"mtc0",    "t,G,H",	0x40800000, 0xffe007f8,	COD|RD_t|WR_C0|WR_CC,	0,		I32	},
 {"mtc1",    "t,S",	0x44800000, 0xffe007ff,	COD|RD_t|WR_S|FP_S,	0,		I1	},
+{"mtc1",    "t,G,#H",  0x44800000, 0xffe007c0, COD|RD_t|WR_S|FP_S,	0,		RLX3	},
 {"mtc1",    "t,G",	0x44800000, 0xffe007ff,	COD|RD_t|WR_S|FP_S,	0,		I1	},
 {"mthc1",   "t,S",	0x44e00000, 0xffe007ff,	COD|RD_t|WR_S|FP_D,	0,		I33	},
 {"mthc1",   "t,G",	0x44e00000, 0xffe007ff,	COD|RD_t|WR_S|FP_D,	0,		I33	},
@@ -1286,8 +1306,8 @@ const struct mips_opcode mips_builtin_op
 {"saad",    "t,(b)",	0x70000019, 0xfc00ffff,	SM|RD_t|RD_b,		0,		IOCTP	},
 {"sb",      "t,o(b)",	0xa0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I1	},
 {"sb",      "t,A(b)",	0,    (int) M_SB_AB,	INSN_MACRO,		0,		I1	},
-{"sc",	    "t,o(b)",	0xe0000000, 0xfc000000, SM|RD_t|WR_t|RD_b,	0,		I2	},
-{"sc",	    "t,A(b)",	0,    (int) M_SC_AB,	INSN_MACRO,		0,		I2	},
+{"sc",	    "t,o(b)",	0xe0000000, 0xfc000000, SM|RD_t|WR_t|RD_b,	0,		I2|RLX2|RLX3	},
+{"sc",	    "t,A(b)",	0,    (int) M_SC_AB,	INSN_MACRO,		0,		I2|RLX2|RLX3	},
 {"scd",	    "t,o(b)",	0xf0000000, 0xfc000000, SM|RD_t|WR_t|RD_b,	0,		I3	},
 {"scd",	    "t,A(b)",	0,    (int) M_SCD_AB,	INSN_MACRO,		0,		I3	},
 /* The macro has to be first to handle o32 correctly.  */
@@ -1297,8 +1317,8 @@ const struct mips_opcode mips_builtin_op
 {"sdbbp",   "",		0x0000000e, 0xffffffff,	TRAP,           	0,		G2	},
 {"sdbbp",   "c",	0x0000000e, 0xfc00ffff,	TRAP,			0,		G2	},
 {"sdbbp",   "c,q",	0x0000000e, 0xfc00003f,	TRAP,			0,		G2	},
-{"sdbbp",   "",         0x7000003f, 0xffffffff, TRAP,           	0,		I32     },
-{"sdbbp",   "B",        0x7000003f, 0xfc00003f, TRAP,           	0,		I32     },
+{"sdbbp",   "",         0x7000003f, 0xffffffff, TRAP,           	0,		I32|RLXA     },
+{"sdbbp",   "B",        0x7000003f, 0xfc00003f, TRAP,           	0,		I32|RLXA     },
 {"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
 {"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
 {"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		INSN2_M_FP_D,	I2	},
@@ -1458,7 +1478,8 @@ const struct mips_opcode mips_builtin_op
 {"sync_release", "",	0x0000048f, 0xffffffff,	NODS,			0,		I33	},
 {"sync_rmb", "",	0x000004cf, 0xffffffff,	NODS,			0,		I33	},
 {"sync_wmb", "",	0x0000010f, 0xffffffff,	NODS,			0,		I33	},
-{"sync",    "",		0x0000000f, 0xffffffff,	NODS,			0,		I2|G1	},
+{"sync",    "",		0x0000000f, 0xffffffff,	NODS,			0,		I2|G1|RLX3	},
+{"sync",    "#I",      0x0000000f, 0xfffff83f, NODS,			0,		RLX3	},
 {"sync",    "1",	0x0000000f, 0xfffff83f,	NODS,			0,		I32	},
 {"sync.p",  "",		0x0000040f, 0xffffffff,	NODS,			0,		I2	},
 {"sync.l",  "",		0x0000000f, 0xffffffff,	NODS,			0,		I2	},
@@ -1555,26 +1576,32 @@ const struct mips_opcode mips_builtin_op
 {"udi0",     "s,t,+2",	0x70000010, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi0",     "s,+3",	0x70000010, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi0",     "+4",	0x70000010, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi0",     "d,v,t", 	0x00000038, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi1",     "s,t,d,+1",0x70000011, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi1",     "s,t,+2",	0x70000011, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi1",     "s,+3",	0x70000011, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi1",     "+4",	0x70000011, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi1",     "d,v,t", 	0x0000003a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi2",     "s,t,d,+1",0x70000012, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi2",     "s,t,+2",	0x70000012, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi2",     "s,+3",	0x70000012, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi2",     "+4",	0x70000012, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi2",     "d,v,t", 	0x0000003b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi3",     "s,t,d,+1",0x70000013, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi3",     "s,t,+2",	0x70000013, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi3",     "s,+3",	0x70000013, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi3",     "+4",	0x70000013, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi3",     "d,v,t", 	0x0000003c, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi4",     "s,t,d,+1",0x70000014, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi4",     "s,t,+2",	0x70000014, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi4",     "s,+3",	0x70000014, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi4",     "+4",	0x70000014, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi4",     "d,v,t", 	0x0000003e, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi5",     "s,t,d,+1",0x70000015, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi5",     "s,t,+2",	0x70000015, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi5",     "s,+3",	0x70000015, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi5",     "+4",	0x70000015, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
+{"udi5",     "d,v,t", 	0x0000003f, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		RLXB	},
 {"udi6",     "s,t,d,+1",0x70000016, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi6",     "s,t,+2",	0x70000016, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
 {"udi6",     "s,+3",	0x70000016, 0xfc00003f,	WR_d|RD_s|RD_t,		0,		I33	},
@@ -1627,7 +1654,9 @@ const struct mips_opcode mips_builtin_op
 {"bc2tl",   "p",	0x49030000, 0xffff0000,	CBL|RD_CC,		0,		I2|T3,		IOCT|IOCTP|IOCT2	},
 {"bc2tl",   "N,p",	0x49030000, 0xffe30000,	CBL|RD_CC,		0,		I32,		IOCT|IOCTP|IOCT2	},
 {"cfc2",    "t,G",	0x48400000, 0xffe007ff,	LCD|WR_t|RD_C2,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cfc2",    "t,G,#H",  0x48400000, 0xffe007c0, LCD|WR_t|RD_C2,		0,		RLX3	},
 {"ctc2",    "t,G",	0x48c00000, 0xffe007ff,	COD|RD_t|WR_CC,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"ctc2",    "t,G,#H",  0x48c00000, 0xffe007c0, COD|RD_t|WR_CC,		0,		RLX3	},
 {"dmfc2",   "t,i",	0x48200000, 0xffe00000,	LCD|WR_t|RD_C2,		0,		IOCT	},
 {"dmfc2",   "t,G",	0x48200000, 0xffe007ff,	LCD|WR_t|RD_C2,		0,		I3,		IOCT|IOCTP|IOCT2	},
 {"dmfc2",   "t,G,H",	0x48200000, 0xffe007f8,	LCD|WR_t|RD_C2,		0,		I64,		IOCT|IOCTP|IOCT2	},
@@ -1635,11 +1664,13 @@ const struct mips_opcode mips_builtin_op
 {"dmtc2",   "t,G",	0x48a00000, 0xffe007ff,	COD|RD_t|WR_C2|WR_CC,	0,		I3,		IOCT|IOCTP|IOCT2	},
 {"dmtc2",   "t,G,H",	0x48a00000, 0xffe007f8,	COD|RD_t|WR_C2|WR_CC,	0,		I64,		IOCT|IOCTP|IOCT2	},
 {"mfc2",    "t,G",	0x48000000, 0xffe007ff,	LCD|WR_t|RD_C2,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"mfc2",    "t,G,#H",  0x48000000, 0xffe007c0, LCD|WR_t|RD_C2,		0,		RLX3	},
 {"mfc2",    "t,G,H",	0x48000000, 0xffe007f8,	LCD|WR_t|RD_C2,		0,		I32,		IOCT|IOCTP|IOCT2	},
 {"mfhc2",   "t,G",	0x48600000, 0xffe007ff,	LCD|WR_t|RD_C2,		0,		I33,		IOCT|IOCTP|IOCT2	},
 {"mfhc2",   "t,G,H",	0x48600000, 0xffe007f8,	LCD|WR_t|RD_C2,		0,		I33,		IOCT|IOCTP|IOCT2	},
 {"mfhc2",   "t,i",	0x48600000, 0xffe00000,	LCD|WR_t|RD_C2,		0,		I33,		IOCT|IOCTP|IOCT2	},
 {"mtc2",    "t,G",	0x48800000, 0xffe007ff,	COD|RD_t|WR_C2|WR_CC,	0,		I1,		IOCT|IOCTP|IOCT2	},
+{"mtc2",    "t,G,#H",  0x48800000, 0xffe007c0, COD|RD_t|WR_C2|WR_CC,	0,		RLX3	},
 {"mtc2",    "t,G,H",	0x48800000, 0xffe007f8,	COD|RD_t|WR_C2|WR_CC,	0,		I32,		IOCT|IOCTP|IOCT2	},
 {"mthc2",   "t,G",	0x48e00000, 0xffe007ff,	COD|RD_t|WR_C2|WR_CC,	0,		I33,		IOCT|IOCTP|IOCT2	},
 {"mthc2",   "t,G,H",	0x48e00000, 0xffe007f8,	COD|RD_t|WR_C2|WR_CC,	0,		I33,		IOCT|IOCTP|IOCT2	},
@@ -1652,12 +1683,16 @@ const struct mips_opcode mips_builtin_op
 {"bc3t",    "p",	0x4d010000, 0xffff0000,	CBD|RD_CC,		0,		I1,		IOCT|IOCTP|IOCT2	},
 {"bc3tl",   "p",	0x4d030000, 0xffff0000,	CBL|RD_CC,		0,		I2|T3,		IOCT|IOCTP|IOCT2	},
 {"cfc3",    "t,G",	0x4c400000, 0xffe007ff,	LCD|WR_t|RD_C3,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cfc3",    "t,G,#H",  0x4c400000, 0xffe007c0, LCD|WR_t|RD_C3,		0,		RLX3	},
 {"ctc3",    "t,G",	0x4cc00000, 0xffe007ff,	COD|RD_t|WR_CC,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"ctc3",    "t,G,#H",   0x4cc00000, 0xffe007c0, COD|RD_t|WR_CC,		0,		RLX3	},
 {"dmfc3",   "t,G",	0x4c200000, 0xffe007ff,	LCD|WR_t|RD_C3,		0,		I3,		IOCT|IOCTP|IOCT2	},
 {"dmtc3",   "t,G",	0x4ca00000, 0xffe007ff,	COD|RD_t|WR_C3|WR_CC,	0,		I3,		IOCT|IOCTP|IOCT2	},
 {"mfc3",    "t,G",	0x4c000000, 0xffe007ff,	LCD|WR_t|RD_C3,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"mfc3",    "t,G,#H",  0x4c000000, 0xffe007c0, LCD|WR_t|RD_C3,		0,		RLX3	},
 {"mfc3",    "t,G,H",	0x4c000000, 0xffe007f8,	LCD|WR_t|RD_C3,		0,		I32,		IOCT|IOCTP|IOCT2	},
 {"mtc3",    "t,G",	0x4c800000, 0xffe007ff,	COD|RD_t|WR_C3|WR_CC,	0,		I1,		IOCT|IOCTP|IOCT2	},
+{"mtc3",    "t,G,#H",  0x4c800000, 0xffe007c0, COD|RD_t|WR_C3|WR_CC,	0,		RLX3	},
 {"mtc3",    "t,G,H",	0x4c800000, 0xffe007f8,	COD|RD_t|WR_C3|WR_CC,	0,		I32,		IOCT|IOCTP|IOCT2	},
 
   /* Conflicts with the 4650's "mul" instruction.  Nobody's using the
@@ -1683,6 +1718,7 @@ const struct mips_opcode mips_builtin_op
 {"addu_s.qb", "d,s,t",	0x7c000110, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		D32	},
 {"addwc",   "d,s,t",	0x7c000450, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		D32	},
 {"bitrev",  "d,t",	0x7c0006d2, 0xffe007ff, WR_d|RD_t,		0,		D32	},
+{"bitrev", "d,t,s", 	0x7c00000c, 0xFC0007FF, RD_s|RD_t|WR_d, 	0, 		RAD1	},
 {"bposge32", "p",	0x041c0000, 0xffff0000, CBD,			0,		D32	},
 {"bposge64", "p",	0x041d0000, 0xffff0000, CBD,			0,		D64	},
 {"cmp.eq.ph", "s,t",	0x7c000211, 0xfc00ffff, RD_s|RD_t,		0,		D32	},
@@ -2108,14 +2144,182 @@ const struct mips_opcode mips_builtin_op
    change the state of the processor and if they do it's up to the
    user to put in nops as necessary.  These are at the end so that the
    disassembler recognizes more specific versions first.  */
-{"c0",      "C",	0x42000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
-{"c1",      "C",	0x46000000, 0xfe000000,	FP_S,			0,		I1	},
-{"c2",      "C",	0x4a000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
-{"c3",      "C",	0x4e000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
-{"cop0",     "C",	0,    (int) M_COP0,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
-{"cop1",     "C",	0,    (int) M_COP1,	INSN_MACRO,		INSN2_M_FP_S,	I1	},
-{"cop2",     "C",	0,    (int) M_COP2,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
-{"cop3",     "C",	0,    (int) M_COP3,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"c0",	"C",	0x42000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
+{"c1",	"C",	0x46000000, 0xfe000000,	FP_S,			0,		I1	},
+{"c2",	"C",	0x4a000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
+{"c3",	"C",	0x4e000000, 0xfe000000,	CP,			0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cop0",	"C",	0,	(int) M_COP0,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cop1",	"C",	0,	(int) M_COP1,	INSN_MACRO,		INSN2_M_FP_S,	I1	},
+{"cop2",	"C",	0,	(int) M_COP2,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
+{"cop3",	"C",	0,	(int) M_COP3,	INSN_MACRO,		0,		I1,		IOCT|IOCTP|IOCT2	},
+/* dbb: modified for supporting radiax instructions */
+/* 2006-01-19 tonywu: cleanup radiax instructions definition */
+/* 2008-07-12 tonywu: add taroko support */
+/* 2008-08-31 tonywu: add rad type */
+/*   d1: m0(3), m1(7), m2(11), m3(15) */
+/*   d2: m0l, m0h, m0 ~ m3l, m3h, m3 */
+/*   d3: m0l, m0h, ~ m3l, m3h */
+/*   d4: LXC0 */
+{"mta2",	"s,#d2",	0x7C00005D, 0xFC1F07ff,	RD_s,		0,	RAD1	},
+{"mta2.g",	"s,#d2",	0x7C00015D, 0xFC1F07ff,	RD_s,		0,	RAD1	},
+{"mfa",		"d,#t3",	0x7C00001C, 0xFFE007FF,	WR_d,		0,	RAD1	},
+{"mfa",		"d,#t3,##",	0x7C00001C, 0xFFE0007F, WR_d,		0,	RAD1	},
+{"mfa2",	"d,#t1",	0x7C00005C, 0xFFE007FF, WR_d,		0,	RAD1	},
+{"mfa2",	"d,#t1,##",	0x7C00005C, 0xFFE0007F, WR_d,		0,	RAD1	},
+{"diva",	"#d1,s,t",	0x7C00001A, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"divau",	"#d1,s,t",	0x7C00021A, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"multa",	"#d1,s,t",	0x7C000112, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"multau",	"#d1,s,t",	0x7C000312, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imulta",	"#d1,s,t",	0x7C000102, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"imultau",	"#d1,s,t",	0x7C000302, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmulta",	"#d1,s,t",	0x7C000502, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"multa2",	"#d2,s,t",	0x7C000152, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imulta2",	"#d2,s,t",	0x7C000142, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmulta2",	"#d2,s,t",	0x7C000542, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"mulna2",	"#d2,s,t",	0x7C000153, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imulna2",	"#d2,s,t",	0x7C000143, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmulna2",	"#d2,s,t",	0x7C000543, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"cmulta",	"#d1,s,t",	0x7C00001B, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"icmulta",	"#d1,s,t",	0x7C00011B, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qcmulta",	"#d1,s,t",	0x7C00051B, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"madda",	"#d1,s,t",	0x7C000012, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"maddau",	"#d1,s,t",	0x7C000212, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imadda",	"#d1,s,t",	0x7C000002, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"imaddau",	"#d1,s,t",	0x7C000202, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmadda",	"#d1,s,t",	0x7C000402, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"madda2",	"#d2,s,t",	0x7C000052, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imadda2",	"#d2,s,t",	0x7C000042, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmadda2",	"#d2,s,t",	0x7C000442, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"madda2.s",	"#d2,s,t",	0x7C0000D2, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imadda2.s32",	"#d2,s,t",	0x7C0000C2, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmadda2.s32",	"#d2,s,t",	0x7C0004C2, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"imadda2.s40",	"#d2,s,t",	0x7C0001C2, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmadda2.s40",	"#d2,s,t",	0x7C0005C2, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"msuba",	"#d1,s,t",	0x7C000013, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"msubau",	"#d1,s,t",	0x7C000213, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imsuba",	"#d1,s,t",	0x7C000003, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"imsubau",	"#d1,s,t",	0x7C000203, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmsuba",	"#d1,s,t",	0x7C000403, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"msuba2",	"#d2,s,t",	0x7C000053, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imsuba2",	"#d2,s,t",	0x7C000043, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmsuba2",	"#d2,s,t",	0x7C000443, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"msuba2.s",	"#d2,s,t",	0x7C0000D3, 0xFC0007FF, RD_t|RD_s,	0,	RAD1	},
+{"imsuba2.s32",	"#d2,s,t",	0x7C0000C3, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmsuba2.s32",	"#d2,s,t",	0x7C0004C3, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"imsuba2.s40",	"#d2,s,t",	0x7C0001C3, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"qmsuba2.s40",	"#d2,s,t",	0x7C0005C3, 0xFC0007FF, RD_t|RD_s,	0,	RAD2	},
+{"addma",	"#d3,#s3,#t3",	0x7C00001E, 0xFC0007FF, 0,		0,	RAD1	},
+{"addma.s",	"#d3,#s3,#t3",	0x7C00009E, 0xFC0007FF, 0,		0,	RAD1	},
+{"addma.s32",	"#d3,#s3,#t3",	0x7C00041E, 0xFC0007FF, 0,		0,	RAD2	},
+{"addma.s40",	"#d3,#s3,#t3",	0x7C00049E, 0xFC0007FF, 0,		0,	RAD2	},
+{"subma",	"#d3,#s3,#t3",	0x7C00001F, 0xFC0007FF, 0,		0,	RAD1	},
+{"subma.s",	"#d3,#s3,#t3",	0x7C00009F, 0xFC0007FF, 0,		0,	RAD1	},
+{"subma.s32",	"#d3,#s3,#t3",	0x7C00041F, 0xFC0007FF, 0,		0,	RAD2	},
+{"subma.s40",	"#d3,#s3,#t3",	0x7C00049F, 0xFC0007FF, 0,		0,	RAD2	},
+{"rnda2",	"#t2",		0x7C000056, 0xFFE0FFFF, 0,		0,	RAD1	},
+{"rnda2",	"#t2,##",	0x7C000056, 0xFFE0F87F, 0,		0,	RAD1	},
+{"lt",		"#`,#@(b)",	0x7C000036, 0xFC00003F, LDD|RD_b|WR_t,	0,	RAD1	},
+{"st",		"#`,#@(b)",	0x7C00003E, 0xFC00003F, SM|RD_t|RD_b,	0,	RAD1	},
+{"ltp",		"#`,(b)#~",	0x7C0000f2, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"ltp.c0",	"#`,(b)#~",	0x7C000032, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"ltp.c1",	"#`,(b)#~",	0x7C000072, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"ltp.c2",	"#`,(b)#~",	0x7C0000b2, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lwp",		"t,(b)#~",	0x7C0000f3, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lwp.c0",	"t,(b)#~",	0x7C000033, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lwp.c1",	"t,(b)#~",	0x7C000073, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lwp.c2",	"t,(b)#~",	0x7C0000b3, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhp",		"t,(b)#~",	0x7C0000f1, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhp.c0",	"t,(b)#~",	0x7C000031, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhp.c1",	"t,(b)#~",	0x7C000071, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhp.c2",	"t,(b)#~",	0x7C0000b1, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhpu",	"t,(b)#~",	0x7C0000f5, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhpu.c0",	"t,(b)#~",	0x7C000035, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhpu.c1",	"t,(b)#~",	0x7C000075, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lhpu.c2",	"t,(b)#~",	0x7C0000b5, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbp",		"t,(b)#~",	0x7C0000f0, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbp.c0",	"t,(b)#~",	0x7C000030, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbp.c1",	"t,(b)#~",	0x7C000070, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbp.c2",	"t,(b)#~",	0x7C0000b0, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbpu",	"t,(b)#~",	0x7C0000f4, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbpu.c0",	"t,(b)#~",	0x7C000034, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbpu.c1",	"t,(b)#~",	0x7C000074, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"lbpu.c2",	"t,(b)#~",	0x7C0000b4, 0xFC0000FF, LDD|WR_t|RD_b,	0,	RAD1	},
+{"stp",		"#`,(b)#~",	0x7C0000fa, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"stp.c0",	"#`,(b)#~",	0x7C00003a, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"stp.c1",	"#`,(b)#~",	0x7C00007a, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"stp.c2",	"#`,(b)#~",	0x7C0000ba, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"swp",		"t,(b)#~",	0x7C0000fb, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"swp.c0",	"t,(b)#~",	0x7C00003b, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"swp.c1",	"t,(b)#~",	0x7C00007b, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"swp.c2",	"t,(b)#~",	0x7C0000bb, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"shp",		"t,(b)#~",	0x7C0000f9, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"shp.c0",	"t,(b)#~",	0x7C000039, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"shp.c1",	"t,(b)#~",	0x7C000079, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"shp.c2",	"t,(b)#~",	0x7C0000b9, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"sbp",		"t,(b)#~",	0x7C0000f8, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"sbp.c0",	"t,(b)#~",	0x7C000038, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"sbp.c1",	"t,(b)#~",	0x7C000078, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"sbp.c2",	"t,(b)#~",	0x7C0000b8, 0xFC0000FF, WR_t|RD_b,	0,	RAD1	},
+{"mtru",	"t,#u",		0x7C000025, 0xFFE007FF, RD_t,		0,	RAD1	},
+{"mfru",	"t,#u",		0x7C000024, 0xFFE007FF, RD_t,		0,	RAD1	},
+{"mtrk",	"t,#k",		0x7C0000A5, 0xFFE007FF, RD_t,		0,	RAD1	},
+{"mfrk",	"t,#k",		0x7C0000A4, 0xFFE007FF, RD_t,		0,	RAD1	},
+{"sllv2",	"d,t,s",	0x7C000044, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"srlv2",	"d,t,s",	0x7C000046, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"srav2",	"d,t,s",	0x7C000047, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"addr",	"d,s,t",	0x7C000021, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"addr.s",	"d,s,t",	0x7C0000A1, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"addr2",	"d,s,t",	0x7C000061, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"addr2.s",	"d,s,t",	0x7C0000E1, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"subr",	"d,s,t",	0x7C000023, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"subr.s",	"d,s,t",	0x7C0000A3, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"subr2",	"d,s,t",	0x7C000063, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"subr2.s",	"d,s,t",	0x7C0000E3, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"sltr2",	"d,s,t",	0x7C00006A, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"min",		"d,s,t",	0x7C000028, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"min2",	"d,s,t",	0x7C000068, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"max",		"d,s,t",	0x7C000029, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"max2",	"d,s,t",	0x7C000069, 0xFC0007FF, RD_t|RD_s|WR_d,	0,	RAD1	},
+{"absr",	"d,t",		0x7C00000F, 0xFFE007FF, RD_t|WR_d,	0,	RAD1	},
+{"absr.s",	"d,t",		0x7C00008F, 0xFFE007FF, RD_t|WR_d,	0,	RAD1	},
+{"absr2",	"d,t",		0x7C00004F, 0xFFE007FF, RD_t|WR_d,	0,	RAD1	},
+{"absr2.s",	"d,t",		0x7C0000CF, 0xFFE007FF, RD_t|WR_d,	0,	RAD1	},
+{"mux2.hh",	"d,s,t",	0x7C00064D, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"mux2.hl",	"d,s,t",	0x7C00044D, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"mux2.lh",	"d,s,t",	0x7C00024D, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"mux2.ll",	"d,s,t",	0x7C00004D, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cls",		"d,t",		0x7C00000E, 0xFFE007FF, RD_t|WR_d,	0,	RAD1	},
+{"cmveqz",	"d,s,t",	0x7C000001, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cmveqz.h",	"d,s,t",	0x7C000081, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cmveqz.l",	"d,s,t",	0x7C000101, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cmvnez",	"d,s,t",	0x7C000041, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cmvnez.h",	"d,s,t",	0x7C0000c1, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+{"cmvnez.l",	"d,s,t",	0x7C000141, 0xFC0007FF, RD_s|RD_t|WR_d,	0,	RAD1	},
+
+
+/* Coprocessor 0 operations */
+{"mflxc0",	"t,#d4",	0x40600000, 0xFFE007FF, LCD|WR_t|RD_C0,		0,	RLXB	},
+{"mflxc0",	"t,#d4,#H",	0x40600000, 0xFFE007C0, LCD|WR_t|RD_C0,		0,	RLX3	},
+{"mtlxc0",	"t,#d4",	0x40E00000, 0xFFE007FF, COD|RD_t|WR_C0|WR_CC,	0,	RLXB	},
+{"mtlxc0",	"t,#d4,#H",	0x40E00000, 0xFFE007C0, COD|RD_t|WR_C0|WR_CC,	0,	RLX3	},
+/*MAC-DIV*/
+{"sleep",	"",		0x42000038, 0xffffffff, 0,		0,	RLXA	},
+{"sleep",	"#I",		0x42000038, 0xfffff83f, 0,		0,	RLX3	},
+{"madh",	"s,t",		0xF0000000, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"madl",	"s,t",		0xF0000002, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"mazh",	"s,t",		0xF0000004, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"mazl",	"s,t",		0xF0000006, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"msbh",	"s,t",		0xF0000010, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"msbl",	"s,t",		0xF0000012, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"mszh",	"s,t",		0xF0000014, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"mszl",	"s,t",		0xF0000016, 0xFC00FFFF, RD_s|RD_t,	0,	RLXA	},
+{"ltw",	"#`,#-(b)",		0x7800003C, 0xFC00003F, LDD|RD_b|WR_t,	0,	INSN_4181|INSN_4281	},
+/* Lexra opcode extensions. Register mode */
+/* Lexra opcode extensions. Immediate mode */
+{"udi0i",	"t,r,j",	0x60000000, 0xfc000000, WR_t|RD_s,	0,	RLXB	},
+{"udi1i",	"t,r,j",	0x64000000, 0xfc000000, WR_t|RD_s,	0,	RLXB	},
+{"udi2i",	"t,r,j",	0x68000000, 0xfc000000, WR_t|RD_s,	0,	RLXB	},
+{"udi3i",	"t,r,j",	0x6c000000, 0xfc000000, WR_t|RD_s,	0,	RLXB	},
 };
 
 #define MIPS_NUM_OPCODES \
